<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Forest's Pocket Jams v16.9</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --plate-color: #222;
            --fr4-color: #2a2a2a;
            --led-off: #2a1111;
            --led-red: #ff3333;
            --led-green: #33ff33;
            --led-blue: #33ccff;
            --led-orange: #ff9900; 
            --led-yellow: #ffcc33;
            --accent-gold: #c5a059;
            --knob-silver: #ddd;
        }

        * { 
            box-sizing: border-box; 
            touch-action: none; 
            -webkit-tap-highlight-color: transparent; 
            user-select: none; 
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }
        
        html, body {
            margin: 0;
            padding: 0;
            background-color: #000;
            color: #eee;
            font-family: 'Courier New', Courier, monospace;
            height: 100%;
            width: 100%;
            overflow: hidden;
            overscroll-behavior: none;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* --- Desktop Instructions --- */
        #desktop-instructions {
            position: fixed;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            width: 280px;
            max-width: 25vw;
            background: rgba(0,0,0,0.85);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #333;
            color: #ccc;
            font-size: 11px;
            line-height: 1.4;
            display: none; 
            pointer-events: none;
            z-index: 100;
            backdrop-filter: blur(4px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        
        #desktop-instructions h3 { 
            color: var(--accent-gold); 
            border-bottom: 1px solid #444; 
            padding-bottom: 8px; 
            margin: 0 0 12px 0; 
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        #desktop-instructions strong { color: #fff; }
        #desktop-instructions ul { padding-left: 0; list-style: none; margin: 0 0 15px 0; }
        #desktop-instructions li { margin-bottom: 6px; display: flex; justify-content: space-between; }
        #desktop-instructions li span:first-child { color: #888; }
        #desktop-instructions .section-title { color: var(--accent-gold); margin-top: 15px; margin-bottom: 5px; font-weight: bold; border-top: 1px solid #333; padding-top: 5px;}

        @media (min-width: 900px) {
            #desktop-instructions { display: block; }
        }

        /* --- Device --- */
        #device {
            width: 90vw;
            max-width: 380px;
            height: 92vh;
            max-height: 720px;
            background-color: var(--plate-color);
            border-radius: 20px;
            position: relative;
            box-shadow: 
                inset 0 0 20px rgba(0,0,0,0.9),
                0 0 0 4px #111,
                0 10px 30px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            padding: 20px;
            background-image: 
                linear-gradient(45deg, #252525 25%, transparent 25%, transparent 75%, #252525 75%, #252525), 
                linear-gradient(45deg, #252525 25%, transparent 25%, transparent 75%, #252525 75%, #252525);
            background-size: 4px 4px;
            background-position: 0 0, 2px 2px;
            transition: filter 0.3s;
            z-index: 10;
        }

        #device.powered-off { filter: brightness(0.4); }
        #device.powered-off .power-switch-container { filter: brightness(2.5); pointer-events: auto; }
        
        #device.powered-off .led-cell,
        #device.powered-off .mic-led,
        #device.powered-off .rec-btn,
        #device.powered-off .pad.active,
        #device.powered-off .pad.has-sample,
        #device.powered-off .mode-btn.selected,
        #device.powered-off .mode-btn.has-audio,
        #device.powered-off .pause-btn,
        #device.powered-off .undo-btn {
            background-color: #111 !important;
            box-shadow: none !important;
            border-color: #333 !important;
            animation: none !important;
            background: #222 !important;
            color: #444 !important;
        }

        /* --- Power Switch --- */
        .power-switch-container {
            position: absolute; top: 160px; right: -12px; left: auto;
            width: 24px; height: 50px; background: #111;
            border: 2px solid #333; border-left: none; border-radius: 0 6px 6px 0;
            z-index: 50; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
        }
        .power-nub {
            width: 12px; height: 20px; background: #444; border-radius: 2px;
            box-shadow: inset 1px 1px 2px rgba(255,255,255,0.2);
            transform: translateY(10px); transition: transform 0.2s, background-color 0.2s;
        }
        .power-active .power-nub {
            transform: translateY(-10px); background-color: var(--accent-gold);
            box-shadow: 0 0 10px var(--accent-gold);
        }

        /* --- LED Strip --- */
        .led-strip {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            margin-bottom: 15px;
            padding: 8px 15px; 
            background: rgba(0,0,0,0.3);
            border-radius: 20px;
            border: 1px solid #333;
        }
        .led-cell {
            width: 8px; height: 8px;
            border-radius: 50%;
            background-color: var(--led-off);
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.9);
            transition: background-color 0.05s, box-shadow 0.05s;
            border: 1px solid #111;
        }
        .led-cell.active-red { background-color: var(--led-red); box-shadow: 0 0 8px var(--led-red), inset 0 1px 2px rgba(255,255,255,0.4); }
        .led-cell.active-green { background-color: var(--led-green); box-shadow: 0 0 8px var(--led-green), inset 0 1px 2px rgba(255,255,255,0.4); }
        .led-cell.active-gold { background-color: var(--accent-gold); box-shadow: 0 0 8px var(--accent-gold), inset 0 1px 2px rgba(255,255,255,0.4); }
        .led-cell.active-yellow { background-color: var(--led-yellow); box-shadow: 0 0 8px var(--led-yellow), inset 0 1px 2px rgba(255,255,255,0.4); }

        /* --- Top: Knobs --- */
        .top-section {
            flex: 1; display: flex; justify-content: center; gap: 40px;
            align-items: center; padding: 10px 0; border-bottom: 2px solid #111; margin-bottom: 10px;
        }
        .knob-container { display: flex; flex-direction: column; align-items: center; width: 80px; }
        .knob-label { font-size: 10px; margin-bottom: 5px; color: #888; font-weight: bold; letter-spacing: 1px; }
        .knob {
            width: 60px; height: 60px; border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #fff, #bbb 60%, #555);
            box-shadow: 0 4px 8px rgba(0,0,0,0.6); position: relative;
            transform: rotate(0deg); transition: transform 0.1s cubic-bezier(0.1, 0.7, 1.0, 0.1);
        }
        .knob::after {
            content: ''; position: absolute; top: 5px; left: 50%;
            transform: translateX(-50%); width: 4px; height: 12px;
            background-color: #333; border-radius: 2px;
        }
        .knurled { border: 2px dashed #666; }

        .mic-grille {
            width: 60px; height: 60px;
            background: radial-gradient(black 15%, transparent 16%) 0 0,
                radial-gradient(black 15%, transparent 16%) 8px 8px,
                radial-gradient(rgba(255,255,255,.1) 15%, transparent 20%) 0 1px,
                radial-gradient(rgba(255,255,255,.1) 15%, transparent 20%) 8px 9px;
            background-color: #222; background-size: 8px 8px; border-radius: 50%; border: 2px solid #444;
            box-shadow: inset 0 2px 6px rgba(0,0,0,0.8); display: flex; justify-content: center; align-items: center;
        }

        /* --- Mid: Looper Controls --- */
        .mid-section {
            flex: 1.5; display: flex; flex-direction: row; align-items: center;
            justify-content: center; gap: 30px; position: relative;
            border: 1px solid #333; background: rgba(0,0,0,0.2);
            border-radius: 8px; padding: 10px; margin-bottom: 10px;
        }
        
        .rec-btn {
            width: 100px; height: 100px; border-radius: 50%;
            /* Default: Dark Red (Inactive) - IDLE STATE */
            background: radial-gradient(circle at 30% 30%, #550000, #330000);
            border: 4px solid #111; 
            box-shadow: 0 6px 0 #200, 0 15px 20px rgba(0,0,0,0.6);
            position: relative; display: flex; justify-content: center; align-items: center;
            transition: all 0.2s; cursor: pointer; z-index: 10;
            color: #fff !important; /* Force white text */
            font-weight: 900; font-size: 16px; letter-spacing: 1px;
            text-shadow: 0 1px 2px rgba(0,0,0,0.8);
            font-family: Arial, sans-serif;
        }
        .rec-btn:active, .rec-btn.active-key { transform: translateY(4px); box-shadow: 0 2px 0 #200; }
        
        /* States for Record Button - Only affect background/shadow */
        .rec-btn.state-recording {
            /* Bright Red - Recording New Material */
            background: radial-gradient(circle at 30% 30%, #ff4444, #cc0000);
            box-shadow: 0 0 20px #f00, 0 6px 0 #500;
        }
        .rec-btn.state-playing {
            /* Green - Playing */
            background: radial-gradient(circle at 30% 30%, #44ff44, #00aa00);
            box-shadow: 0 0 20px #0f0, 0 6px 0 #050;
        }
        .rec-btn.state-overdub {
            /* Yellow - Overdubbing Existing Material */
            background: radial-gradient(circle at 30% 30%, #ffee44, #ccaa00);
            box-shadow: 0 0 20px #ff0, 0 6px 0 #880;
        }
        .rec-btn.state-standby-red {
            /* Flashing Red - Armed for First Loop or Fresh Track */
             animation: pulse-red 1s infinite alternate;
             background: radial-gradient(circle at 30% 30%, #ff4444, #cc0000);
        }
        .rec-btn.state-standby-yellow {
            /* Flashing Yellow - Armed for Overdub */
             animation: pulse-yellow 1s infinite alternate;
             background: radial-gradient(circle at 30% 30%, #ffee44, #ccaa00);
        }

        @keyframes pulse-red { from { box-shadow: 0 0 5px #f00; opacity: 0.8; } to { box-shadow: 0 0 20px #f00; opacity: 1; } }
        @keyframes pulse-yellow { from { box-shadow: 0 0 5px #ff0; opacity: 0.8; } to { box-shadow: 0 0 20px #ff0; opacity: 1; } }

        .undo-btn {
            width: 50px; height: 50px; border-radius: 50%;
            /* Orange for Undo */
            background: radial-gradient(circle at 30% 30%, #ffaa00, #cc6600);
            border: 2px solid #111; color: #fff; font-size: 24px; font-weight: bold;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 4px 0 #442200, 0 5px 10px rgba(0,0,0,0.5);
            cursor: pointer; transition: all 0.1s;
        }
        .undo-btn:active, .undo-btn.active-key { transform: translateY(2px); box-shadow: 0 2px 0 #442200; }
        .undo-btn.reset-flash { background: #fff; box-shadow: 0 0 20px #fff; }

        /* New Pause Button Style - Always Blue */
        .pause-btn {
            width: 50px; height: 50px; border-radius: 50%;
            /* Blue Always */
            background: radial-gradient(circle at 30% 30%, #33ccff, #006699);
            border: 2px solid #111; color: #fff; font-size: 16px; font-weight: bold;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 4px 0 #002233, 0 5px 10px rgba(0,0,0,0.5);
            cursor: pointer; transition: all 0.1s;
            font-family: monospace;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }
        .pause-btn:active { transform: translateY(2px); box-shadow: 0 2px 0 #002233; }
        /* Paused State: Keeps blue, icon changes in JS */
        .pause-btn.paused { 
            /* Same blue */
             background: radial-gradient(circle at 30% 30%, #33ccff, #006699);
             box-shadow: 0 4px 0 #002233; 
             opacity: 0.8;
        }

        @keyframes flash-white { 0% { background-color: #fff; color: #000; } 100% { background-color: #222; color: #555; } }
        .flash-trigger { animation: flash-white 0.2s ease-out; }

        /* --- Modes --- */
        .mode-section { display: flex; justify-content: space-around; width: 100%; margin-bottom: 15px; position: relative; padding: 0 10px; }
        
        .scale-switch-wrapper {
            position: absolute; 
            top: 2px; 
            left: 8px; 
            display: flex; 
            flex-direction: column;
            align-items: center; 
            gap: 2px;
            z-index: 20;
        }
        .scale-label { font-size: 7px; color: #666; font-weight: bold; }
        .scale-toggle {
            width: 14px; height: 30px; background: #111; border: 1px solid #444; border-radius: 10px;
            position: relative; cursor: pointer;
        }
        .scale-toggle::after {
            content: ''; position: absolute; top: 1px; left: 1px; width: 10px; height: 10px;
            background: #666; border-radius: 50%; transition: top 0.2s, background 0.2s;
        }
        .scale-toggle.minor::after { top: 17px; background: var(--accent-gold); }

        /* Instrument Buttons */
        .mode-btn {
            width: 50px; height: 50px; border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #444, #222);
            border: 2px solid #111; color: #666; font-size: 20px;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 4px 0 #000, 0 5px 10px rgba(0,0,0,0.5);
            cursor: pointer; transition: all 0.1s;
            position: relative;
        }

        .mode-btn:active { transform: translateY(2px); box-shadow: 0 2px 0 #000; }

        /* HAS AUDIO (Content exists, but not selected) */
        .mode-btn.has-audio {
            color: var(--led-green);
            border-color: #004400;
        }

        /* MUTED */
        .mode-btn.muted {
            color: #500;
            border-color: #300;
            opacity: 0.6;
        }
        .mode-btn.muted::after {
            content: '‚ùå'; font-size: 12px; position: absolute; bottom: -5px; right: -5px;
        }

        /* SELECTED (Overrides others visually for border/bg) */
        .mode-btn.selected {
            background: radial-gradient(circle at 30% 30%, #223344, #001122); /* Darker Blue BG */
            color: var(--led-blue);
            border-color: var(--led-blue);
            box-shadow: 0 0 15px rgba(51, 204, 255, 0.6), 0 4px 0 #000;
            z-index: 5;
        }

        /* --- Pads --- */
        .pads-container {
            flex: 2; display: grid; grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(2, 1fr); gap: 8px; width: 100%;
        }
        .pad {
            background: rgba(255,255,255,0.05); border-radius: 6px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.8); transition: background 0.05s;
        }
        .pad.active { background: rgba(255, 200, 100, 0.4) !important; box-shadow: 0 0 15px rgba(255, 200, 100, 0.6) !important; }
        .pad.recording-armed { background-color: #500; border: 1px solid #f00; }
        .pad.recording { background-color: #f00; box-shadow: 0 0 15px #f00; }
        
        /* New "Has Sample" Style: White/Glass fill, NO red border */
        .mode-voice .pad.has-sample { 
            background: rgba(255, 255, 255, 0.15); 
            box-shadow: 0 0 10px rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
        }

        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            text-align: center; color: var(--accent-gold); padding: 20px;
        }
        #overlay button {
            margin-top: 20px; padding: 15px 30px; background: var(--accent-gold);
            border: none; font-weight: bold; font-size: 16px; cursor: pointer;
        }
        #status-log {
            position: absolute; bottom: 5px; left: 0; width: 100%;
            text-align: center; font-size: 10px; color: #666; pointer-events: none;
        }
    </style>
</head>
<body oncontextmenu="return false;">

<div id="desktop-instructions">
    <h3>USER MANUAL v16.9</h3>
    <div class="section-title">BASICS</div>
    <ul>
        <li><span>LOOP</span> <strong>Tap REC (Toggle) or Hold</strong></li>
        <li><span>OVERDUB</span> <strong>ARM by Tap, Signal Starts</strong></li>
        <li><span>VOICE SAMPLE</span> <strong>Hold PAD + REC</strong></li>
    </ul>
    
    <div class="section-title">TRACK CONTROL</div>
    <ul>
        <li><span>MUTE TRACK</span> <strong>Hold INSTRUMENT + Press PAUSE</strong></li>
        <li><span>CLEAR TRACK</span> <strong>Hold UNDO (1s)</strong></li>
        <li><span>UNMUTE</span> <strong>Tap INSTRUMENT + PAUSE</strong></li>
        <li><span>CLEAR ALL</span> <strong>Hold UNDO + Press REC</strong></li>
    </ul>
    
    <div class="section-title">KEYBOARD SHORTCUTS</div>
    <ul>
        <li><span>REC</span> <strong>SHIFT</strong></li>
        <li><span>UNDO</span> <strong>CTRL</strong></li>
        <li><span>INSTRUMENTS</span> <strong>1 / 2 / 3</strong></li>
        <li><span>PADS (TOP)</span> <strong>Q W E R</strong></li>
        <li><span>PADS (BOT)</span> <strong>A S D F</strong></li>
        <li><span>POWER</span> <strong>SPACE</strong></li>
    </ul>

    <div class="section-title">SOUND DESIGN</div>
    <ul>
        <li><span>CHANGE SOUND</span> <strong>Click Instrument Btn</strong></li>
        <li><span>SYNTH SCALE</span> <strong>Switch above Synth</strong></li>
        <li><span>FX KNOB</span> <strong>Reverb (L) / Delay (R)</strong></li>
        <li><span>SPEED KNOB</span> <strong>Slow (L) / Fast (R)</strong></li>
    </ul>
</div>

<div id="device">
    <div class="power-switch-container" id="power-switch">
        <div class="power-nub"></div>
    </div>

    <div class="led-strip" id="led-strip">
        <div class="led-cell" id="led-0"></div>
        <div class="led-cell" id="led-1"></div>
        <div class="led-cell" id="led-2"></div>
        <div class="led-cell" id="led-3"></div>
        <div class="led-cell" id="led-4"></div>
        <div class="led-cell" id="led-5"></div>
        <div class="led-cell" id="led-6"></div>
        <div class="led-cell" id="led-7"></div>
    </div>

    <div class="top-section">
        <div class="knob-container">
            <div class="knob-label">REV / DELAY</div>
            <div class="knob knurled" id="knob-glitch"></div>
        </div>
        <div class="mic-grille"></div>
        <div class="knob-container">
            <div class="knob-label">SLOW / FAST</div>
            <div class="knob knurled" id="knob-speed"></div>
        </div>
    </div>

    <div class="mid-section">
        <div class="pause-btn" id="btn-pause">‚ùö‚ùö</div>
        <div class="rec-btn" id="btn-rec">‚óè REC</div>
        <div class="undo-btn" id="btn-undo">‚Ü∫</div>
    </div>

    <div class="mode-section">
        <div class="scale-switch-wrapper" id="scale-wrapper">
            <div class="scale-label">MAJ</div>
            <div class="scale-toggle" id="scale-switch"></div>
            <div class="scale-label">MIN</div>
        </div>

        <div class="mode-btn" data-mode="synth" id="btn-synth">üéπ</div>
        <div class="mode-btn" data-mode="voice" id="btn-voice">üéôÔ∏è</div>
        <div class="mode-btn selected" data-mode="drums" id="btn-drums">ü•Å</div>
    </div>

    <div class="pads-container" id="pads-grid"></div>
    <div id="status-log"></div>
</div>

<div id="overlay">
    <h2>FOREST'S POCKET JAMS</h2>
    <p>Version 16.9</p>
    
        <p style="font-size: 11px; color: #ffffff; margin-top: 10px; line-height: 1.6;">
 
        <span>LOOP/DUB:</span> <strong>Tap REC (Toggle) or Hold</strong><br>
        <span>VOICE SAMPLE:</span> <strong>Hold PAD + REC</strong><br>
        <span>MUTE TRACK:</span> <strong>Hold Inst Button + Press PAUSE</strong><br>
        <span>CLEAR TRACK:</span> <strong>Hold UNDO (1s)</strong><br>
        <span>CLEAR ALL:</span> <strong>Hold UNDO + Press REC</strong><br>
        <span style="color:#aaa; display:block; margin-top:5px; border-top:1px solid #444; padding-top:5px;">
        Tap Instrument Button to Cycle Sounds<br>
        Keys: 1=Synth, 2=Voice, 3=Drums
        </span>

    </p>
    <p style="font-size: 12px; color: #888; margin-top: 10px;">
        Headphones Recommended.<br>
        Microphone Access Required.
    </p>
    <button id="start-btn">START JAMMING</button>
</div>

<script>
/**
 * FOREST'S POCKET JAMROOM - V16.9
 * - Visuals: Pause is Blue/Symbol change, Undo is Orange
 * - Feature: Instant Quantized Stop (Crops/Pads loop to 1/4, 1/2, 1x, 2x master length)
 * - Control: Clear Track = Hold Undo (1s)
 * - Control: Reset Jam = Hold Undo + Press REC
 */

const AudioContext = window.AudioContext || window.webkitAudioContext;
let ctx;
let masterGain, compressor;
let analyser;
let micStream, micNode;
let micCompressor;

// --- Multi-Track Architecture ---
const TRACKS = ['drums', 'synth', 'voice'];
let trackCtx = {
    drums: { bus: null, gain: null, buffer: null, source: null, loopGain: null, mute: false, hasContent: false },
    synth: { bus: null, gain: null, buffer: null, source: null, loopGain: null, mute: false, hasContent: false },
    voice: { bus: null, gain: null, buffer: null, source: null, loopGain: null, mute: false, hasContent: false }
};

// Undo Storage
let undoBackup = null; 
let undoTrackName = null;
let isUndoHeld = false; // New flag for shortcuts

// FX Nodes
let reverbBuffer = null;
let fxBus, fxReturn; 
let instReverb, instDelay, instFeedback, instDelayGain;

// Recording Gates
let recGates = { drums: null, synth: null, voice: null };
// Special Bus for Voice Recording (Mic + Samples)
let voiceRecordingBus; 

let micGateGain;     
let micMonitorGain;

// Sample Playback State
let isSamplePlaying = false;
let samplePlayTimer = null;

const STATE = { 
    IDLE: 0, 
    ARMED: 1, 
    RECORDING_1: 2, 
    PLAYING: 3, 
    OVERDUB: 4, 
    SAMPLING_ARMED: 5, 
    SAMPLING_REC: 6,
    OVERDUB_ARMED: 7 
};
let currentState = STATE.IDLE;
let currentMode = 'drums';
let lastInstrumentMode = 'drums'; 
let isPowered = true;
let isMinorScale = false;

// Interaction State
let heldInstrument = null; 
let instHoldStartTime = 0;

// EXPANDED SOUND LIBRARY
const DRUM_STYLES = ['Standard', '808', 'Glass', 'Zap', 'Glitch', 'Game'];
const SYNTH_STYLES = ['Saw Lead', 'Deep Bass', 'Soft Sine', 'Retro Pad', 'Pluck', 'Chords', 'Acid', 'Dream'];
let currentDrumIdx = 0; let currentSynthIdx = 0;
const DRUM_PADS = ['kick', 'snare', 'hat', 'tom', 'clap', 'perc1', 'perc2', 'crash'];

// SCALES (Root C4)
const SCALE_MAJOR = [261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88, 523.25];
const SCALE_MINOR = [261.63, 293.66, 311.13, 349.23, 392.00, 415.30, 466.16, 523.25];

// Loop State
let masterLoopLength = 0; 
let loopStartTime = 0;
let inputThreshold = 0.04;
let undoStack = []; let undoTimeout; let hasReset = false;
let minLoopLength = 2000;
let autoStopTimer = null; 

let userSamples = new Array(8).fill(null);
let heldPadIndex = -1;
let recordingPadIndex = -1; 
let sampleRecBuffer = [];

let playbackRate = 1.0;
let recStartTime = 0; 
let recPressTime = 0; 
let recordingStream = [];

// UI
const els = {
    knobSpeed: document.getElementById('knob-speed'),
    knobGlitch: document.getElementById('knob-glitch'), 
    recBtn: document.getElementById('btn-rec'),
    undoBtn: document.getElementById('btn-undo'),
    overlay: document.getElementById('overlay'),
    startBtn: document.getElementById('start-btn'),
    padsGrid: document.getElementById('pads-grid'),
    modes: document.querySelectorAll('.mode-btn'),
    status: document.getElementById('status-log'),
    device: document.getElementById('device'),
    powerSwitch: document.getElementById('power-switch'),
    scaleSwitch: document.getElementById('scale-switch'),
    ledStrip: document.getElementById('led-strip'),
    ledCells: Array.from(document.querySelectorAll('.led-cell'))
};

function log(msg) {
    els.status.innerText = msg;
    setTimeout(() => { if(els.status.innerText === msg) els.status.innerText = ''; }, 2000);
}

// Mobile Pinch Prevent
document.addEventListener('gesturestart', function(e) { e.preventDefault(); });
document.addEventListener('gesturechange', function(e) { e.preventDefault(); });
document.addEventListener('gestureend', function(e) { e.preventDefault(); });
document.addEventListener('touchmove', function(e) { if(e.scale !== 1) e.preventDefault(); }, { passive: false });
document.addEventListener('dblclick', function(e) { e.preventDefault(); }, { passive: false });


els.startBtn.addEventListener('click', async () => {
    try {
        ctx = new AudioContext();
        await ctx.resume();
        
        // Master Bus
        compressor = ctx.createDynamicsCompressor();
        compressor.threshold.value = -12;
        compressor.ratio.value = 12;
        masterGain = ctx.createGain();
        masterGain.gain.value = 0.9;
        compressor.connect(masterGain);
        masterGain.connect(ctx.destination);

        // --- Track Setup ---
        TRACKS.forEach(track => {
            trackCtx[track].bus = ctx.createGain(); 
            trackCtx[track].loopGain = ctx.createGain(); 
            trackCtx[track].loopGain.connect(compressor); 
            
            recGates[track] = ctx.createGain();
            recGates[track].gain.value = (currentMode === track) ? 1 : 0;
            if (track !== 'voice') {
                trackCtx[track].bus.connect(recGates[track]);
            }
        });

        // Special Voice Setup
        voiceRecordingBus = ctx.createGain();
        voiceRecordingBus.connect(recGates['voice']);

        // FX Bus
        setupSharedFX();

        // Connect Track Buses
        TRACKS.forEach(track => {
            trackCtx[track].bus.connect(fxBus);
            trackCtx[track].bus.connect(compressor);
        });

        analyser = ctx.createAnalyser();
        analyser.fftSize = 256;

        // Mic Setup
        try {
            micStream = await navigator.mediaDevices.getUserMedia({ audio: { 
                echoCancellation: false, noiseSuppression: false, autoGainControl: false, latency: 0 
            }});
            micNode = ctx.createMediaStreamSource(micStream);
            
            micCompressor = ctx.createDynamicsCompressor();
            micCompressor.threshold.value = -24;
            micCompressor.knee.value = 30;
            micCompressor.ratio.value = 12;
            micCompressor.attack.value = 0.003;
            micCompressor.release.value = 0.25;
            
            micNode.connect(micCompressor);
            
            // Analyser connected to MIC (for Ducking logic)
            micCompressor.connect(analyser); 
            
            micGateGain = ctx.createGain();
            micGateGain.gain.value = 0; 
            
            micCompressor.connect(micGateGain);
            
            // CRITICAL: Route Mic to Voice RECORDING Bus ONLY.
            micGateGain.connect(voiceRecordingBus);
            
            // NEW: Route Mic to FX Bus for Reverb/Delay on Voice
            micGateGain.connect(fxBus); 
            
        } catch (e) { console.warn("Mic access denied."); }

        initUI(); initPads(); setupKeys();
        requestAnimationFrame(updateLoop);
        els.overlay.style.display = 'none';
        els.powerSwitch.classList.add('power-active'); 
        setupRecorder();
        
    } catch (e) { alert("Audio Init Failed: " + e); }
});

function setupSharedFX() {
    reverbBuffer = createReverbBuffer();

    fxBus = ctx.createGain();
    fxReturn = ctx.createGain();
    
    instReverb = ctx.createConvolver(); instReverb.buffer = reverbBuffer;
    let irGain = ctx.createGain(); irGain.gain.value = 0; instReverb.gainNode = irGain;
    
    fxBus.connect(instReverb); instReverb.connect(irGain); irGain.connect(fxReturn);
    
    instDelay = ctx.createDelay(1.0); instDelay.delayTime.value = 0.3;
    instFeedback = ctx.createGain(); instFeedback.gain.value = 0.3;
    instDelayGain = ctx.createGain(); instDelayGain.gain.value = 0;
    
    fxBus.connect(instDelay); instDelay.connect(instFeedback); instFeedback.connect(instDelay);
    instDelay.connect(instDelayGain); instDelayGain.connect(fxReturn);
    
    fxReturn.connect(compressor);
}

function createReverbBuffer() {
    const len = ctx.sampleRate * 2.0; 
    const buffer = ctx.createBuffer(2, len, ctx.sampleRate);
    for (let c = 0; c < 2; c++) {
        const data = buffer.getChannelData(c);
        for (let i = 0; i < len; i++) data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / len, 3);
    }
    return buffer;
}

// --- Sound Engine ---
function playDrum(type) {
    const t = ctx.currentTime; const gain = ctx.createGain(); 
    gain.connect(trackCtx.drums.bus);
    const style = DRUM_STYLES[currentDrumIdx];

    const humanize = (val, amt) => val + ((Math.random() * amt * 2) - amt);

    const hit = (freq, decay, type='sine', vol=1) => {
        const osc = ctx.createOscillator(); osc.type = type;
        const f = humanize(freq, freq * 0.02);
        osc.frequency.setValueAtTime(f, t); osc.frequency.exponentialRampToValueAtTime(10, t + decay);
        gain.gain.setValueAtTime(humanize(vol, 0.1), t); gain.gain.exponentialRampToValueAtTime(0.01, t + decay);
        osc.connect(gain); osc.start(t); osc.stop(t + decay);
    };
    
    const noise = (dur, vol, time, hp) => makeNoise(dur, vol, time, hp, trackCtx.drums.bus);

    if (style === 'Glass') {
        if(type === 'kick') { playFM(60, 120, 200, 0.5, 0.9, t); } 
        else if(type === 'snare') { playFM(400, 850, 500, 0.2, 0.7, t); noise(0.15, 0.5, t, true); } 
        else if(type === 'hat') { playFM(3000, 4100, 1000, 0.05, 0.4, t); } 
        else if(type === 'tom') { playFM(200, 280, 150, 0.4, 0.6, t); } 
        else if(type === 'clap') { playFM(800, 1200, 300, 0.1, 0.5, t); noise(0.05, 0.3, t+0.02, true); } 
        else if(type === 'crash') { playFM(1000, 234, 2000, 1.2, 0.5, t); noise(0.5, 0.3, t, true); } 
        else { playFM(1500, 2000, 400, 0.1, 0.4, t); } 
        return;
    }

    if(type === 'kick') {
        if(style === '808') hit(60, 0.8, 'sine', 1);
        else if(style === 'Zap') { hit(200, 0.2, 'sawtooth', 0.8); noise(0.05, 0.2, t, true); }
        else if(style === 'Game') { hit(120, 0.1, 'square', 0.6); }
        else if(style === 'Glitch') { hit(100, 0.05, 'triangle', 0.8); noise(0.02, 0.5, t); } 
        else hit(150, 0.3);
    } 
    else if(type === 'snare') {
        if(style === '808') { hit(200, 0.1, 'triangle', 0.5); noise(0.2, 0.4, t); }
        else if(style === 'Zap') { hit(400, 0.1, 'sawtooth', 0.5); noise(0.1, 0.6, t, true); }
        else if(style === 'Game') { noise(0.1, 0.5, t); }
        else if(style === 'Glitch') { noise(0.01, 0.8, t); noise(0.01, 0.8, t+0.02); } 
        else { hit(250, 0.1, 'triangle', 0.5); noise(0.15, 0.7, t); }
    }
    else if(type === 'hat') {
        let len = (style === '808') ? 0.05 : 0.08;
        if(style === 'Glitch') len = 0.02;
        if(style === 'Game') { noise(0.05, 0.3, t, true); return; }
        noise(len, 0.3, t, true);
    }
    else if(type === 'tom') {
        if(style === 'Zap') { hit(600, 0.3, 'sawtooth', 0.4); }
        else if(style === 'Glitch') { hit(200, 0.05, 'sawtooth', 0.5); }
        else hit(150, 0.4, 'sine', 0.8);
    }
    else if(type === 'clap') {
        if(style === 'Glitch') { noise(0.01, 0.6, t); noise(0.01, 0.6, t+0.05); }
        else { noise(0.01, 0.6, t); noise(0.01, 0.5, t+0.015); noise(0.01, 0.4, t+0.03); noise(0.1, 0.3, t+0.04); }
    }
    else if(type === 'crash') {
        if(style === 'Zap') { hit(800, 0.6, 'sawtooth', 0.3); noise(0.5, 0.4, t, true); }
        else noise(0.8, 0.6, t, true);
    }
    else { noise(0.1, 0.5, t); }
}

function makeNoise(duration, vol, time, highpass = false, dest) {
    const bufferSize = ctx.sampleRate * duration; const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = buffer.getChannelData(0); for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
    const noise = ctx.createBufferSource(); noise.buffer = buffer; const noiseGain = ctx.createGain();
    noiseGain.gain.setValueAtTime(vol, time); noiseGain.gain.exponentialRampToValueAtTime(0.01, time + duration);
    noise.connect(noiseGain); 
    
    if(highpass) { 
        const hp = ctx.createBiquadFilter(); hp.type = 'highpass'; hp.frequency.value = 5000; 
        noiseGain.connect(hp); hp.connect(dest); 
    } 
    else { noiseGain.connect(dest); } 
    noise.start(time);
}

function playFM(carrierFreq, modFreq, modIndex, decay, vol, time) {
    const carrier = ctx.createOscillator();
    const modulator = ctx.createOscillator();
    const modGain = ctx.createGain();
    const outGain = ctx.createGain();

    carrier.frequency.value = carrierFreq;
    modulator.frequency.value = modFreq;
    modGain.gain.value = modIndex;

    outGain.gain.setValueAtTime(vol, time);
    outGain.gain.exponentialRampToValueAtTime(0.01, time + decay);

    modulator.connect(modGain);
    modGain.connect(carrier.frequency);
    carrier.connect(outGain);
    outGain.connect(trackCtx.drums.bus);

    carrier.start(time); modulator.start(time);
    carrier.stop(time + decay); modulator.stop(time + decay);
}

function playSynth(rawFreq) {
    const t = ctx.currentTime;
    const style = SYNTH_STYLES[currentSynthIdx];
    const gain = ctx.createGain(); 
    gain.connect(trackCtx.synth.bus);
    
    let f = rawFreq; 

    if(style === 'Saw Lead') {
        const osc = ctx.createOscillator(); osc.type = 'sawtooth'; osc.frequency.value = f;
        const filter = ctx.createBiquadFilter(); filter.type = 'lowpass';
        filter.frequency.setValueAtTime(200, t); filter.frequency.exponentialRampToValueAtTime(4000, t + 0.1);
        gain.gain.setValueAtTime(0, t); gain.gain.linearRampToValueAtTime(0.4, t+0.02); gain.gain.exponentialRampToValueAtTime(0.01, t+0.6);
        osc.connect(filter); filter.connect(gain); osc.start(t); osc.stop(t+0.6);
    }
    else if (style === 'Deep Bass') {
        const osc1 = ctx.createOscillator(); osc1.type = 'sine'; osc1.frequency.value = f / 2;
        const osc2 = ctx.createOscillator(); osc2.type = 'square'; osc2.frequency.value = f / 2;
        const filter = ctx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.value = 400;
        osc1.connect(gain); osc2.connect(filter); filter.connect(gain);
        gain.gain.setValueAtTime(0.8, t); gain.gain.exponentialRampToValueAtTime(0.01, t+0.6);
        osc1.start(t); osc1.stop(t+0.6); osc2.start(t); osc2.stop(t+0.6);
    }
    else if (style === 'Chords') {
        [f, f*1.5, f*2].forEach((fr, i) => {
            const osc = ctx.createOscillator(); osc.type = 'sawtooth'; osc.frequency.value = fr;
            osc.detune.value = Math.random()*10 - 5;
            const lg = ctx.createGain(); lg.gain.value = 0.2 / (i+1);
            osc.connect(lg); lg.connect(gain);
            osc.start(t); osc.stop(t+0.6);
        });
        gain.gain.setValueAtTime(0, t); gain.gain.linearRampToValueAtTime(1, t+0.05); gain.gain.exponentialRampToValueAtTime(0.01, t+0.6);
    }
    else if (style === 'Acid') {
        const osc = ctx.createOscillator(); osc.type = 'sawtooth'; osc.frequency.value = f;
        const filter = ctx.createBiquadFilter(); filter.type = 'lowpass'; filter.Q.value = 20;
        filter.frequency.setValueAtTime(300, t); filter.frequency.linearRampToValueAtTime(2000, t+0.2); filter.frequency.linearRampToValueAtTime(300, t+0.5);
        osc.connect(filter); filter.connect(gain);
        gain.gain.setValueAtTime(0.4, t); gain.gain.exponentialRampToValueAtTime(0.01, t+0.5);
        osc.start(t); osc.stop(t+0.5);
    }
    else if (style === 'Dream') {
        const osc = ctx.createOscillator(); osc.type = 'triangle'; osc.frequency.value = f;
        const osc2 = ctx.createOscillator(); osc2.type = 'triangle'; osc2.frequency.value = f; osc2.detune.value = 15;
        gain.gain.setValueAtTime(0, t); gain.gain.linearRampToValueAtTime(0.4, t+0.3); gain.gain.linearRampToValueAtTime(0, t+1.5);
        osc.connect(gain); osc2.connect(gain);
        osc.start(t); osc.stop(t+1.5); osc2.start(t); osc2.stop(t+1.5);
    }
    else {
        const osc = ctx.createOscillator(); osc.type = (style==='Pluck')?'square':'triangle'; osc.frequency.value = f;
        const filter = ctx.createBiquadFilter(); filter.frequency.value = 2000;
        if(style==='Pluck') { filter.frequency.exponentialRampToValueAtTime(200, t+0.2); }
        gain.gain.setValueAtTime(0.5, t); gain.gain.exponentialRampToValueAtTime(0.01, t+0.4);
        osc.connect(filter); filter.connect(gain); osc.start(t); osc.stop(t+0.4);
    }
}

function playSample(index) {
    if(!userSamples[index]) return;
    isSamplePlaying = true;
    updateMicGate();
    
    if(samplePlayTimer) clearTimeout(samplePlayTimer);
    
    const src = ctx.createBufferSource(); src.buffer = userSamples[index]; 
    src.connect(trackCtx.voice.bus); 
    src.connect(voiceRecordingBus);
    src.start(0);
    
    samplePlayTimer = setTimeout(() => {
        isSamplePlaying = false;
        updateMicGate();
    }, src.buffer.duration * 1000);
}

function isRecordingState() {
    return (currentState === STATE.RECORDING_1 || currentState === STATE.OVERDUB || currentState === STATE.ARMED || currentState === STATE.SAMPLING_ARMED || currentState === STATE.SAMPLING_REC || currentState === STATE.OVERDUB_ARMED);
}

// --- Recorder ---
const bufferSize = 2048;
let recorderNode;

function setupRecorder() {
    if(recorderNode) return;
    recorderNode = ctx.createScriptProcessor(bufferSize, 1, 1);
    recorderNode.onaudioprocess = (e) => {
        if (!isRecordingState()) return;
        
        const input = e.inputBuffer.getChannelData(0);
        let rms = 0; for(let i=0; i<input.length; i++) rms += input[i]*input[i]; rms = Math.sqrt(rms/input.length);
        
        if (currentState === STATE.SAMPLING_ARMED || currentState === STATE.ARMED || currentState === STATE.OVERDUB_ARMED) {
             if (rms < 0.001) { for(let i=0; i<input.length; i++) input[i] = 0; }
        }

        if (currentState === STATE.SAMPLING_ARMED && rms > inputThreshold) {
            currentState = STATE.SAMPLING_REC; sampleRecBuffer = [];
            if (recordingPadIndex !== -1) els.padsGrid.children[recordingPadIndex].classList.add('recording');
            log("SAMPLING..."); updateMicGate(); updateBackingTrackVolume(); updateRecBtnVisual();
        }
        else if (currentState === STATE.ARMED && rms > inputThreshold) startFirstRecording();
        else if (currentState === STATE.OVERDUB_ARMED && rms > inputThreshold) startOverdubRecording();

        if (currentState === STATE.SAMPLING_REC) { sampleRecBuffer.push(new Float32Array(input)); return; }
        if (currentState === STATE.RECORDING_1 || currentState === STATE.OVERDUB) recordingStream.push(new Float32Array(input));
        
        const output = e.outputBuffer.getChannelData(0); for (let i = 0; i < output.length; i++) output[i] = 0; 
    };
    
    TRACKS.forEach(t => recGates[t].connect(recorderNode));
    
    if(fxReturn) fxReturn.connect(recorderNode);
    
    const zeroGain = ctx.createGain(); zeroGain.gain.value = 0; recorderNode.connect(zeroGain); zeroGain.connect(ctx.destination);
}

function toggleMute(trackName) {
    const t = trackCtx[trackName];
    t.mute = !t.mute;
    updateBackingTrackVolume();
    updateUI();
    log(t.mute ? `MUTE ${trackName.toUpperCase()}` : `UNMUTE ${trackName.toUpperCase()}`);
}

function clearTrack(trackName) {
    trackCtx[trackName].buffer = null;
    trackCtx[trackName].hasContent = false; // Mark as empty
    trackCtx[trackName].mute = false;
    
    // CHECK IF ALL TRACKS ARE CLEARED -> RESET
    const allCleared = TRACKS.every(t => !trackCtx[t].hasContent);
    
    if (allCleared) {
        resetDevice();
    } else {
        if (masterLoopLength > 0) {
            trackCtx[trackName].buffer = ctx.createBuffer(1, masterLoopLength, ctx.sampleRate);
            if(trackCtx[trackName].source) restartPlayback();
        }
        selectTrack(trackName); // Switch without cycling sound
        log(`CLEARED ${trackName.toUpperCase()}`);
        updateRecBtnVisual();
    }
}

function updateBackingTrackVolume() {
    const isSampling = (currentState === STATE.SAMPLING_ARMED || currentState === STATE.SAMPLING_REC);
    const isVoiceOverdub = (currentMode === 'voice' && (currentState === STATE.RECORDING_1 || currentState === STATE.OVERDUB));
    
    TRACKS.forEach(t => {
        let targetGain = 1.0;
        if (trackCtx[t].mute) {
            targetGain = 0.0;
        } else {
            if (isSampling) { targetGain = 0.0; }
            else if (isVoiceOverdub) { targetGain = 0.3; }
        }
        if (trackCtx[t].loopGain) {
            trackCtx[t].loopGain.gain.setTargetAtTime(targetGain, ctx.currentTime, 0.05);
        }
    });
}

function updateRecBtnVisual() {
    // Reset classes
    els.recBtn.classList.remove('state-recording', 'state-playing', 'state-overdub', 'state-standby-red', 'state-standby-yellow');
    
    const hasLoop = (masterLoopLength > 0);
    const trackHasContent = trackCtx[currentMode].hasContent;

    if (currentState === STATE.RECORDING_1 || currentState === STATE.SAMPLING_REC) {
        els.recBtn.classList.add('state-recording');
    } 
    else if (currentState === STATE.OVERDUB) {
        if (trackHasContent) {
            els.recBtn.classList.add('state-overdub'); // Yellow
        } else {
            els.recBtn.classList.add('state-recording'); // Red (Recording new track)
        }
    } 
    else if (currentState === STATE.ARMED || currentState === STATE.SAMPLING_ARMED) {
         els.recBtn.classList.add('state-standby-red');
    }
    else if (currentState === STATE.OVERDUB_ARMED) {
        if (trackHasContent) {
            els.recBtn.classList.add('state-standby-yellow');
        } else {
            els.recBtn.classList.add('state-standby-red');
        }
    } 
    else if (currentState === STATE.PLAYING) {
        els.recBtn.classList.add('state-playing');
    }
}

// --- Control Logic ---
function onRecPress() {
    if(!isPowered) return;
    
    // FIX 4: CLEAR ALL GESTURE (Hold Undo + Rec)
    if (isUndoHeld) {
        resetDevice();
        // Reset flag so releasing Undo doesn't trigger clearTrack
        isUndoHeld = false; 
        return;
    }
    
    if (trackCtx[currentMode].mute) toggleMute(currentMode);

    if (currentMode === 'voice' && heldPadIndex !== -1) {
        recordingPadIndex = heldPadIndex;
        currentState = STATE.SAMPLING_ARMED; sampleRecBuffer = [];
        const pad = els.padsGrid.children[recordingPadIndex];
        if(pad) pad.classList.add('recording-armed');
        log("ARMED: SPEAK"); 
        updateMicGate(); 
        updateBackingTrackVolume(); 
        updateRecBtnVisual();
        return;
    }

    recPressTime = Date.now();

    if (currentState === STATE.IDLE) {
        currentState = STATE.ARMED; recordingStream = []; 
        log("ARMED: MAKE SOUND"); updateMicGate();
    } 
    else if (currentState === STATE.ARMED) {
        currentState = STATE.IDLE; log("CANCELLED"); updateMicGate();
    }
    else if (currentState === STATE.PLAYING) {
        armOverdub();
    }
    else if (currentState === STATE.OVERDUB_ARMED) {
        currentState = STATE.PLAYING; log("CANCELLED"); updateMicGate();
    }
    else if (currentState === STATE.RECORDING_1) {
        finishFirstLoop();
    }
    else if (currentState === STATE.OVERDUB) {
        handleOverdubStop(); 
    }
    updateRecBtnVisual();
}

function onRecRelease() {
    if (currentState === STATE.SAMPLING_REC || currentState === STATE.SAMPLING_ARMED) {
        finishSampling(); return;
    }
    const duration = Date.now() - recPressTime;
    const isLongPress = duration > 500;

    if (isLongPress) {
        if (currentState === STATE.RECORDING_1) finishFirstLoop(); 
        else if (currentState === STATE.ARMED) {
             currentState = STATE.IDLE; log("CANCELLED"); updateMicGate(); 
        }
        else if (currentState === STATE.OVERDUB_ARMED) {
             currentState = STATE.PLAYING; log("CANCELLED"); updateMicGate(); 
        }
    }
    updateRecBtnVisual();
}

function finishSampling() {
    if (currentState === STATE.SAMPLING_REC && sampleRecBuffer.length > 0 && recordingPadIndex !== -1) {
        const totalSamples = sampleRecBuffer.length * bufferSize;
        const rawBuffer = ctx.createBuffer(1, totalSamples, ctx.sampleRate);
        const data = rawBuffer.getChannelData(0); let offset = 0;
        for(let chunk of sampleRecBuffer) { data.set(chunk, offset); offset += chunk.length; }
        userSamples[recordingPadIndex] = rawBuffer;
        log("SAMPLE SAVED");
    } else { log("SAMPLE CANCELLED"); }
    
    if (recordingPadIndex !== -1) {
        const pad = els.padsGrid.children[recordingPadIndex];
        if(pad) { pad.classList.remove('recording'); pad.classList.remove('recording-armed'); }
    }
    
    recordingPadIndex = -1;
    currentState = (masterLoopLength > 0) ? STATE.PLAYING : STATE.IDLE; 
    
    updateMicGate(); 
    updateBackingTrackVolume(); 
    updatePadVisuals();
    updateRecBtnVisual();
}

function startFirstRecording() {
    currentState = STATE.RECORDING_1;
    recordingStream = []; recStartTime = ctx.currentTime; 
    log("RECORDING..."); 
    updateMicGate();
    updateBackingTrackVolume(); 
    updateRecBtnVisual();
}

function finishFirstLoop() {
    const totalSamples = recordingStream.length * bufferSize;
    if(totalSamples < minLoopLength) { currentState = STATE.IDLE; log("TOO SHORT"); updateMicGate(); updateRecBtnVisual(); return; }
    
    currentState = STATE.PLAYING; 
    masterLoopLength = totalSamples;
    
    const rawBuffer = ctx.createBuffer(1, totalSamples, ctx.sampleRate); 
    const data = rawBuffer.getChannelData(0); let offset = 0;
    for(let chunk of recordingStream) { data.set(chunk, offset); offset += chunk.length; }
    
    undoTrackName = currentMode;
    undoBackup = null; 
    
    trackCtx[currentMode].buffer = rawBuffer;
    trackCtx[currentMode].hasContent = true;

    TRACKS.forEach(t => {
        if (t !== currentMode) {
            trackCtx[t].buffer = ctx.createBuffer(1, totalSamples, ctx.sampleRate);
            trackCtx[t].hasContent = false;
        }
    });

    startPlayback(); log("LOOPING"); 
    updateMicGate(); 
    updateBackingTrackVolume(); 
    updateUI();
    updateRecBtnVisual();
}

function armOverdub() {
    if(masterLoopLength === 0) return;
    currentState = STATE.OVERDUB_ARMED;
    log("ARMED: DUB");
    updateMicGate();
    updateRecBtnVisual();
}

function startOverdubRecording() {
    const isOverdubbingExisting = trackCtx[currentMode].hasContent;
    
    // Auto-stop logic: Only applies if we are overdubbing on top of existing material
    // New tracks (isOverdubbingExisting = false) do NOT auto-stop anymore.
    if (masterLoopLength > 0 && isOverdubbingExisting) {
        const loopDuration = masterLoopLength / ctx.sampleRate;
        const rate = Math.abs(playbackRate) || 1.0;
        const timeToRecord = loopDuration / rate; 
        
        clearTimeout(autoStopTimer);
        autoStopTimer = setTimeout(() => {
            if (currentState === STATE.OVERDUB) {
                log("AUTO STOP");
                performStopOverdub(); 
            }
        }, timeToRecord * 1000);
    }

    currentState = STATE.OVERDUB; 
    recordingStream = []; 
    recStartTime = ctx.currentTime; 
    log("DUBBING..."); 
    updateMicGate();
    updateBackingTrackVolume(); 
    updateRecBtnVisual();
}

// FIX 2: INSTANT SMART SYNC
function handleOverdubStop() {
    const isNewTrack = !trackCtx[currentMode].hasContent;
    
    // Only smart-sync if we are creating a fresh loop on a new track
    if (isNewTrack && masterLoopLength > 0) {
        const currentSampleCount = recordingStream.length * bufferSize;
        const ratios = [0.25, 0.5, 1.0, 2.0, 4.0];
        const targets = ratios.map(r => Math.floor(masterLoopLength * r));
        
        // Find nearest target length
        let bestTarget = targets[0];
        let minDiff = Math.abs(currentSampleCount - bestTarget);
        
        for (let t of targets) {
            const diff = Math.abs(currentSampleCount - t);
            if (diff < minDiff) {
                minDiff = diff;
                bestTarget = t;
            }
        }
        
        // We now have the "Ideal" length. We will force the recording to this length.
        // If actual recording is shorter -> Pad with silence.
        // If actual recording is longer -> Crop.
        
        // Flatten recorded stream
        const totalRecorded = recordingStream.length * bufferSize;
        const flatStream = new Float32Array(totalRecorded);
        let offset = 0;
        for(let chunk of recordingStream) { flatStream.set(chunk, offset); offset += chunk.length; }
        
        // Create perfect buffer
        const finalBuffer = ctx.createBuffer(1, bestTarget, ctx.sampleRate);
        const finalData = finalBuffer.getChannelData(0);
        
        // Copy data (up to the limit of either)
        const copyAmount = Math.min(totalRecorded, bestTarget);
        finalData.set(flatStream.subarray(0, copyAmount));
        
        // (Optional: Small fade out at the splice point to prevent clicking if we cropped)
        if (copyAmount > 100) {
            for(let i=0; i<100; i++) {
                finalData[copyAmount - 1 - i] *= (i/100);
            }
        }

        // Apply
        trackCtx[currentMode].buffer = finalBuffer;
        trackCtx[currentMode].hasContent = true;
        
        undoBackup = null; 
        undoTrackName = currentMode;
        
        log("SYNCED LOOP");
        
        currentState = STATE.PLAYING; 
        updateMicGate();
        updateBackingTrackVolume();
        updateRecBtnVisual();
        
        restartPlayback();
        return;
    }
    
    performStopOverdub();
}

function performStopOverdub() {
    clearTimeout(autoStopTimer); 
    
    currentState = STATE.PLAYING; log("PLAYING"); 
    updateMicGate();
    updateBackingTrackVolume(); 
    
    if(masterLoopLength === 0 || recordingStream.length === 0) { updateRecBtnVisual(); return; }

    const isOverdubbingExisting = trackCtx[currentMode].hasContent;

    if (trackCtx[currentMode].buffer) {
        const existingBuf = trackCtx[currentMode].buffer;
        undoBackup = ctx.createBuffer(1, existingBuf.length, existingBuf.sampleRate);
        undoBackup.copyToChannel(existingBuf.getChannelData(0), 0);
        undoTrackName = currentMode;
        log("DUBBED (UNDO AVAIL)");
    } else {
        undoBackup = null;
        undoTrackName = currentMode;
    }

    if (isOverdubbingExisting) {
        const targetBuffer = trackCtx[currentMode].buffer;
        const oldData = targetBuffer.getChannelData(0);
        const loopTotalSamples = masterLoopLength;
        
        let timeElapsed = ctx.currentTime - loopStartTime;
        let currentLoopPos = (timeElapsed * ctx.sampleRate * playbackRate) % loopTotalSamples;
        while(currentLoopPos < 0) currentLoopPos += loopTotalSamples;
        while(currentLoopPos >= loopTotalSamples) currentLoopPos -= loopTotalSamples;

        let latencySamples = 512; 
        if (currentMode === 'voice') latencySamples = 12000; 
        
        currentLoopPos -= (playbackRate * latencySamples);
        while(currentLoopPos < 0) currentLoopPos += loopTotalSamples;
        while(currentLoopPos >= loopTotalSamples) currentLoopPos -= loopTotalSamples;

        const flatRecLen = recordingStream.length * bufferSize;
        const flatRec = new Float32Array(flatRecLen);
        let off = 0;
        for(let chunk of recordingStream) { flatRec.set(chunk, off); off += chunk.length; }
        
        for (let i = 0; i < flatRecLen; i++) {
            const inputSample = flatRec[flatRecLen - 1 - i];
            let targetIndex = currentLoopPos - (i * playbackRate);
            while(targetIndex < 0) targetIndex += loopTotalSamples;
            while(targetIndex >= loopTotalSamples) targetIndex -= loopTotalSamples;
            oldData[Math.floor(targetIndex)] += inputSample;
        }
    } else {
        const totalSamples = recordingStream.length * bufferSize;
        const rawBuffer = ctx.createBuffer(1, totalSamples, ctx.sampleRate);
        const data = rawBuffer.getChannelData(0); let offset = 0;
        for(let chunk of recordingStream) { data.set(chunk, offset); offset += chunk.length; }
        
        trackCtx[currentMode].buffer = rawBuffer;
        trackCtx[currentMode].hasContent = true;
        log("NEW LOOP ADDED");
        
        restartPlayback();
    }
    
    trackCtx[currentMode].hasContent = true; 
    
    updateUI();
    updateRecBtnVisual();
}

function startPlayback() {
    stopAllSources();
    loopStartTime = ctx.currentTime;

    TRACKS.forEach(t => {
        if(trackCtx[t].buffer) {
            trackCtx[t].source = ctx.createBufferSource();
            trackCtx[t].source.buffer = trackCtx[t].buffer;
            trackCtx[t].source.loop = true;
            trackCtx[t].source.loopStart = 0;
            trackCtx[t].source.loopEnd = trackCtx[t].buffer.duration;
            trackCtx[t].source.playbackRate.value = playbackRate;
            trackCtx[t].source.connect(trackCtx[t].loopGain); 
            trackCtx[t].source.start(0);
        }
    });
}

function stopAllSources() {
    TRACKS.forEach(t => {
        if(trackCtx[t].source) { try { trackCtx[t].source.stop(); } catch(e){} trackCtx[t].source = null; }
    });
}

function restartPlayback() {
    if(masterLoopLength > 0) startPlayback();
}

// --- UI Logic ---
function initPads() {
    els.padsGrid.innerHTML = '';
    for(let i=0; i<8; i++) {
        const btn = document.createElement('div'); btn.className = 'pad';
        btn.addEventListener('pointerdown', (e) => { 
            e.preventDefault(); if(!isPowered) return;
            btn.setPointerCapture(e.pointerId); heldPadIndex = i; btn.classList.add('active'); hitPad(i, btn); 
        });
        btn.addEventListener('pointerup', (e) => { heldPadIndex = -1; btn.classList.remove('active'); btn.releasePointerCapture(e.pointerId); });
        btn.addEventListener('pointercancel', (e) => { heldPadIndex = -1; btn.classList.remove('active'); btn.releasePointerCapture(e.pointerId); });
        els.padsGrid.appendChild(btn);
    }
}

function updatePadVisuals() {
    const pads = Array.from(els.padsGrid.children);
    pads.forEach((pad, i) => {
        pad.classList.remove('has-sample');
        if (currentMode === 'voice' && userSamples[i]) pad.classList.add('has-sample');
    });
    if(currentMode === 'voice') els.padsGrid.classList.add('mode-voice');
    else els.padsGrid.classList.remove('mode-voice');
}

function hitPad(index, el) {
    if (currentMode === 'voice') {
        if (userSamples[index]) playSample(index);
    } else {
        if (currentMode === 'drums') playDrum(DRUM_PADS[index]);
        else if (currentMode === 'synth') {
            const freqs = isMinorScale ? SCALE_MINOR : SCALE_MAJOR;
            playSynth(freqs[index]);
        }
    }
}

function updateMicGate() {
    const isSampling = (currentState === STATE.SAMPLING_ARMED || currentState === STATE.SAMPLING_REC);
    const isVoiceRecording = (currentMode === 'voice' && (currentState === STATE.RECORDING_1 || currentState === STATE.OVERDUB || currentState === STATE.ARMED || currentState === STATE.OVERDUB_ARMED));
    
    let target = (isSampling || isVoiceRecording) ? 1.0 : 0.0;
    if (isSamplePlaying) target = 0.0;
    micGateGain.gain.setTargetAtTime(target, ctx.currentTime, 0.05);
}

// Helper to select track without cycling
function selectTrack(newMode) {
    const btn = Array.from(els.modes).find(b => b.dataset.mode === newMode);
    
    // Update Gates
    TRACKS.forEach(t => {
        recGates[t].gain.setTargetAtTime((t === newMode) ? 1 : 0, ctx.currentTime, 0.02);
    });

    if(currentMode !== 'voice') lastInstrumentMode = currentMode;
    currentMode = newMode; 
    updateUI();
    updatePadVisuals(); 
    updateMicGate();
    updateBackingTrackVolume(); 
    updateRecBtnVisual();
    log("MODE: " + currentMode.toUpperCase());
}

function cycleSound(mode) {
    if(mode === 'drums') { 
        currentDrumIdx = (currentDrumIdx + 1) % DRUM_STYLES.length; 
        log("DRUMS: " + DRUM_STYLES[currentDrumIdx]); 
    } else if(mode === 'synth') { 
        currentSynthIdx = (currentSynthIdx + 1) % SYNTH_STYLES.length; 
        log("SYNTH: " + SYNTH_STYLES[currentSynthIdx]); 
    }
    const btn = Array.from(els.modes).find(b => b.dataset.mode === mode);
    btn.style.transform = "scale(0.9)"; setTimeout(() => btn.style.transform = "", 100);
}

function initUI() {
    els.modes.forEach(btn => {
        const mode = btn.dataset.mode;
        // Pointer Down: Select Track immediately
        btn.addEventListener('pointerdown', (e) => { 
            if(!isPowered) return;
            btn.dataset.wasSelected = (mode === currentMode);
            heldInstrument = mode; 
            instHoldStartTime = Date.now();
            selectTrack(mode);
        });
        
        // Pointer Up: Check for Cycle (Tap) vs Hold
        btn.addEventListener('pointerup', (e) => { 
            if(!isPowered) return;
            const duration = Date.now() - instHoldStartTime;
            if (duration < 300) {
                 if (btn.dataset.wasSelected === 'true') {
                     cycleSound(mode);
                 }
            }
            heldInstrument = null; 
        });
        
        btn.addEventListener('pointerleave', (e) => { heldInstrument = null; });
    });

    els.scaleSwitch.addEventListener('click', () => {
        if(!isPowered) return;
        isMinorScale = !isMinorScale;
        els.scaleSwitch.classList.toggle('minor', isMinorScale);
        log("SCALE: " + (isMinorScale ? "MINOR" : "MAJOR"));
    });

    els.recBtn.addEventListener('pointerdown', (e) => { if(!isPowered) return; e.preventDefault(); els.recBtn.setPointerCapture(e.pointerId); onRecPress(); });
    els.recBtn.addEventListener('pointerup', (e) => { e.preventDefault(); onRecRelease(); els.recBtn.releasePointerCapture(e.pointerId); });
    els.recBtn.addEventListener('pointercancel', (e) => { onRecRelease(); els.recBtn.releasePointerCapture(e.pointerId); });
    els.powerSwitch.addEventListener('click', togglePower);

    setupKnob(els.knobSpeed, (val) => {
        if(!isPowered) return;
        if (val > 0.45 && val < 0.55) { playbackRate = 1.0; }
        else if (val >= 0.55) { if (val < 0.9) { playbackRate = 1.0 + ((val-0.55)/0.35)*1.5; } else { playbackRate = -2.0; } } 
        else if (val <= 0.45) { playbackRate = 1.0 - ((0.45 - val) / 0.225); }
        if (Math.abs(playbackRate) < 0.001) playbackRate = 0.001;
        
        TRACKS.forEach(t => { if(trackCtx[t].source) trackCtx[t].source.playbackRate.value = playbackRate; });
        
    }, true); 

    setupKnob(els.knobGlitch, (val) => {
        if(!isPowered || !instReverb) return;
        let rGain, dGain, dFeed;
        if (val > 0.45 && val < 0.55) { rGain=0; dGain=0; dFeed=0; }
        else if (val >= 0.55) { rGain=0; const norm = (val-0.55)/0.45; dGain=norm*0.8; dFeed=0.2+(norm*0.5); } 
        else if (val <= 0.45) { dGain=0; dFeed=0; const norm = (0.45-val)/0.45; rGain=norm*1.5; }
        
        instReverb.gainNode.gain.value = rGain; 
        instDelayGain.gain.value = dGain; 
        instFeedback.gain.value = dFeed; 
    }, true);
}

function togglePower() {
    isPowered = !isPowered;
    if(isPowered) { els.powerSwitch.classList.add('power-active'); els.device.classList.remove('powered-off'); ctx.resume(); log("RESUME"); } 
    else { els.powerSwitch.classList.remove('power-active'); els.device.classList.add('powered-off'); ctx.suspend(); }
    updateRecBtnVisual();
}

function setupKnob(el, callback, magnet = false) {
    let startY = 0; let currentDeg = 0;
    const update = (y) => {
        const delta = startY - y; currentDeg += delta * 2; currentDeg = Math.min(135, Math.max(-135, currentDeg));
        let visualDeg = currentDeg; if (magnet && Math.abs(currentDeg) < 15) visualDeg = 0;
        el.style.transform = `rotate(${visualDeg}deg)`; callback((visualDeg + 135) / 270); startY = y;
    };
    el.addEventListener('pointerdown', e => { if(!isPowered) return; startY = e.clientY; el.setPointerCapture(e.pointerId);
        const move = e => update(e.clientY);
        const up = () => { el.removeEventListener('pointermove', move); el.removeEventListener('pointerup', up); el.releasePointerCapture(e.pointerId); };
        el.addEventListener('pointermove', move); el.addEventListener('pointerup', up);
    });
}

function updateLedBar(micLevel) {
    const isRecording = (currentState === STATE.RECORDING_1 || currentState === STATE.ARMED);
    const isPlaying = (currentState === STATE.PLAYING || currentState === STATE.OVERDUB);
    
    els.ledCells.forEach(led => led.className = 'led-cell');

    if (isRecording) {
        const level = Math.min(8, Math.floor(micLevel / 10)); 
        for(let i=0; i<level; i++) els.ledCells[i].classList.add('active-red');
    } 
    else if (isPlaying && masterLoopLength > 0) {
        const duration = masterLoopLength / ctx.sampleRate;
        const current = ((ctx.currentTime - loopStartTime) * Math.abs(playbackRate)) % duration;
        const progress = current / duration; 
        const activeIdx = Math.floor(progress * 8); 

        const colorClass = (currentState === STATE.OVERDUB) ? 'active-yellow' : 'active-green';
        for(let i=0; i<=activeIdx; i++) if(i < 8) els.ledCells[i].classList.add(colorClass);
    }
}

function updateLoop() {
    let micLevel = 0;
    if(isPowered) {
        if (analyser) {
            const data = new Uint8Array(analyser.frequencyBinCount); analyser.getByteFrequencyData(data);
            let sum = 0; for(let v of data) sum += v;
            micLevel = sum / data.length;
        }
        updateLedBar(micLevel);
    } 
    requestAnimationFrame(updateLoop);
}

// Shortcuts
function setupKeys() {
    const padKeys = { 'q':0, 'w':1, 'e':2, 'r':3, 'a':4, 's':5, 'd':6, 'f':7 };
    let recKeyDown = false;
    let undoKeyDown = false;

    window.addEventListener('keydown', (e) => {
        if(!isPowered) return;
        if(e.repeat) return;
        
        if(e.key === '1') { 
            const btn = document.getElementById('btn-synth');
            btn.dataset.wasSelected = ('synth' === currentMode);
            heldInstrument = 'synth'; 
            instHoldStartTime = Date.now(); 
            selectTrack('synth'); 
        }
        if(e.key === '2') { 
            const btn = document.getElementById('btn-voice');
            btn.dataset.wasSelected = ('voice' === currentMode);
            heldInstrument = 'voice'; 
            instHoldStartTime = Date.now(); 
            selectTrack('voice'); 
        }
        if(e.key === '3') { 
            const btn = document.getElementById('btn-drums');
            btn.dataset.wasSelected = ('drums' === currentMode);
            heldInstrument = 'drums'; 
            instHoldStartTime = Date.now(); 
            selectTrack('drums'); 
        }

        if(e.key === 'Control') {
            if(!undoKeyDown) {
                undoKeyDown = true;
                els.undoBtn.classList.add('active-key');
                startUndoTimer({ pointerId: -1 }); 
            }
        }

        const k = e.key.toLowerCase();
        if(k in padKeys) {
            const idx = padKeys[k]; heldPadIndex = idx;
            const btn = els.padsGrid.children[idx];
            if(btn) { btn.classList.add('active'); hitPad(idx, btn); }
        }
        if(e.key === 'Shift') { if(!recKeyDown) { recKeyDown = true; els.recBtn.classList.add('active-key'); onRecPress(); } }
        if(e.key === ' ') { e.preventDefault(); togglePower(); }
    });
    
    window.addEventListener('keyup', (e) => {
        if(!isPowered) return;
        
        if(e.key === '1' || e.key === '2' || e.key === '3') {
             // Handle Keyboard Tap vs Hold logic
             const duration = Date.now() - instHoldStartTime;
             let mode = (e.key==='1'?'synth':(e.key==='3'?'drums':'voice'));
             let btn = (mode==='synth'?document.getElementById('btn-synth'):(mode==='drums'?document.getElementById('btn-drums'):document.getElementById('btn-voice')));
             
             if(duration < 300) {
                 if(btn.dataset.wasSelected === 'true') {
                     if(e.key === '1') cycleSound('synth');
                     if(e.key === '3') cycleSound('drums');
                 }
             }
             heldInstrument = null;
        }

        if(e.key === 'Control') {
            undoKeyDown = false;
            els.undoBtn.classList.remove('active-key');
            endUndoTimer({ pointerId: -1 });
        }

        const k = e.key.toLowerCase();
        if(k in padKeys) {
            const idx = padKeys[k]; heldPadIndex = -1;
            const btn = els.padsGrid.children[idx]; if(btn) btn.classList.remove('active');
        }
        if(e.key === 'Shift') { recKeyDown = false; els.recBtn.classList.remove('active-key'); onRecRelease(); }
    });
}

// Undo
els.undoBtn.addEventListener('pointerdown', startUndoTimer);
els.undoBtn.addEventListener('pointerup', endUndoTimer);
els.undoBtn.addEventListener('pointercancel', endUndoTimer);

function startUndoTimer(e) { 
    if(!isPowered) return; 
    if(e.pointerId >= 0) els.undoBtn.setPointerCapture(e.pointerId); 
    hasReset = false; 
    isUndoHeld = true; // FIX 4: Flag for Rec combo
    
    undoTimeout = setTimeout(() => {
        // HOLD ACTION (1s) -> CLEAR CURRENT TRACK
        hasReset = true;
        // Previously this cleared the held instrument.
        // User requested: "hold the undo button and it will clear whatever instrument is currently selected."
        clearTrack(currentMode);
        
    }, 1000); 
}

function endUndoTimer(e) { 
    clearTimeout(undoTimeout); 
    if(e.pointerId >= 0) els.undoBtn.releasePointerCapture(e.pointerId);
    
    // Release the flag
    // Use a small delay in case the click handler needs it? No, sync is fine.
    isUndoHeld = false;
    
    // TAP ACTION (Short Press)
    if (!hasReset && isPowered) {
        performUndo(); 
    }
}

// FIX 1: UNDO / REDO SWAP LOGIC
function performUndo() {
    if(currentMode === 'voice' && heldPadIndex !== -1) {
        if(userSamples[heldPadIndex]) { userSamples[heldPadIndex] = null; updatePadVisuals(); log("SAMPLE DELETED"); return; }
    }
    
    if(undoTrackName && undoTrackName === undoTrackName) {
        const activeTracksCount = TRACKS.filter(t => trackCtx[t].hasContent).length;
        if (undoBackup === null && activeTracksCount <= 1) {
            log("CAN'T UNDO LAST");
            return;
        }

        const t = undoTrackName;
        const tempBuffer = trackCtx[t].buffer;
        trackCtx[t].buffer = undoBackup;
        undoBackup = tempBuffer;
        
        trackCtx[t].hasContent = !!trackCtx[t].buffer;
        
        log(trackCtx[t].buffer ? "REDO" : "UNDO");
        
        if(currentState === STATE.PLAYING || currentState === STATE.OVERDUB) {
             restartPlayback();
        }
        updateUI();
        updateRecBtnVisual();
        return;
    }

    log("NOTHING TO UNDO");
}

function resetDevice() {
    hasReset = true; stopAllSources();
    masterLoopLength = 0; recordingStream = []; 
    TRACKS.forEach(t => { 
        trackCtx[t].buffer = null; 
        trackCtx[t].mute = false; 
        trackCtx[t].hasContent = false;
    });
    
    undoBackup = null; 
    undoTrackName = null;

    updateUI();
    currentState = STATE.IDLE; 
    updateRecBtnVisual(); 
    els.undoBtn.classList.add('reset-flash'); setTimeout(() => els.undoBtn.classList.remove('reset-flash'), 500);
    log("RESET ALL");
}

function updateUI() {
    els.modes.forEach(btn => {
        const mode = btn.dataset.mode;
        btn.classList.remove('selected', 'has-audio', 'muted');
        
        if (mode === currentMode) btn.classList.add('selected');
        if (trackCtx[mode].mute) btn.classList.add('muted');
        
        if (mode !== currentMode && !trackCtx[mode].mute && trackCtx[mode].buffer) {
            if (masterLoopLength > 0) btn.classList.add('has-audio');
        }
    });
}

// Pause Button Logic
const pauseBtn = document.getElementById('btn-pause');
let isGlobalMuted = false;
pauseBtn.addEventListener('click', () => {
    // SHORTCUT CHECK: Is an instrument held?
    if (heldInstrument) {
        toggleMute(heldInstrument);
        return;
    }

    isGlobalMuted = !isGlobalMuted;
    if (isGlobalMuted) {
        masterGain.gain.setTargetAtTime(0, ctx.currentTime, 0.1);
        pauseBtn.classList.add('paused');
        pauseBtn.innerText = "‚ñ∂"; // Visual Fix
    } else {
        masterGain.gain.setTargetAtTime(0.9, ctx.currentTime, 0.1);
        pauseBtn.classList.remove('paused');
        pauseBtn.innerText = "‚ùö‚ùö";
    }
});
</script>
</body>
</html>