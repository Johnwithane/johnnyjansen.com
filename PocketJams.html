<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Forest's Pocket Jams</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --plate-color: #222;
            --fr4-color: #2a2a2a;
            --led-off: #331111;
            --led-red: #ff3333;
            --led-green: #33ff33;
            --led-blue: #33ccff;
            --accent-gold: #c5a059;
            --knob-silver: #ddd;
        }

        * { 
            box-sizing: border-box; 
            touch-action: none; 
            -webkit-tap-highlight-color: transparent; 
            user-select: none; 
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }
        
        html, body {
            margin: 0;
            padding: 0;
            background-color: #000;
            color: #eee;
            font-family: 'Courier New', Courier, monospace;
            height: 100%;
            width: 100%;
            overflow: hidden;
            overscroll-behavior: none;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* --- Desktop Instructions --- */
        #desktop-instructions {
            position: fixed;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            width: 260px;
            max-width: 25vw; /* Shrink if window is narrow */
            background: rgba(0,0,0,0.85);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #333;
            color: #ccc;
            font-size: 12px;
            line-height: 1.4;
            display: none; 
            pointer-events: none; /* Click through */
            z-index: 100; /* Always on top */
            backdrop-filter: blur(4px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        
        #desktop-instructions h3 { 
            color: var(--accent-gold); 
            border-bottom: 1px solid #444; 
            padding-bottom: 8px; 
            margin: 0 0 12px 0; 
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        #desktop-instructions strong { color: #fff; }
        #desktop-instructions ul { padding-left: 0; list-style: none; margin: 0 0 15px 0; }
        #desktop-instructions li { margin-bottom: 6px; display: flex; justify-content: space-between; }
        #desktop-instructions li span:first-child { color: #888; }

        @media (min-width: 900px) {
            #desktop-instructions { display: block; }
        }

        /* --- Device --- */
        #device {
            width: 90vw;
            max-width: 380px;
            height: 90vh;
            max-height: 700px;
            background-color: var(--plate-color);
            border-radius: 20px;
            position: relative;
            box-shadow: 
                inset 0 0 20px rgba(0,0,0,0.9),
                0 0 0 4px #111,
                0 10px 30px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            padding: 20px;
            background-image: 
                linear-gradient(45deg, #252525 25%, transparent 25%, transparent 75%, #252525 75%, #252525), 
                linear-gradient(45deg, #252525 25%, transparent 25%, transparent 75%, #252525 75%, #252525);
            background-size: 4px 4px;
            background-position: 0 0, 2px 2px;
            transition: filter 0.3s;
            z-index: 10;
        }

        #device.powered-off { filter: brightness(0.4); }
        #device.powered-off .power-switch-container { filter: brightness(2.5); pointer-events: auto; }
        
        #device.powered-off .mic-led,
        #device.powered-off .rec-led-ring,
        #device.powered-off .pad.active,
        #device.powered-off .pad.has-sample {
            background-color: #111 !important;
            box-shadow: none !important;
            border-color: #333 !important;
            animation: none !important;
        }

        /* --- Power Switch --- */
        .power-switch-container {
            position: absolute; top: 140px; right: -12px; left: auto;
            width: 24px; height: 50px; background: #111;
            border: 2px solid #333; border-left: none; border-radius: 0 6px 6px 0;
            z-index: 50; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
        }
        .power-nub {
            width: 12px; height: 20px; background: #444; border-radius: 2px;
            box-shadow: inset 1px 1px 2px rgba(255,255,255,0.2);
            transform: translateY(-10px); transition: transform 0.2s, background-color 0.2s;
        }
        .power-active .power-nub {
            transform: translateY(10px); background-color: var(--accent-gold);
            box-shadow: 0 0 10px var(--accent-gold);
        }

        /* --- Top: Knobs --- */
        .top-section {
            flex: 1; display: flex; justify-content: space-between;
            align-items: center; padding: 10px 0; border-bottom: 2px solid #111; margin-bottom: 10px;
        }
        .knob-container { display: flex; flex-direction: column; align-items: center; width: 80px; }
        .knob-label { font-size: 10px; margin-bottom: 5px; color: #888; font-weight: bold; letter-spacing: 1px; }
        .knob {
            width: 60px; height: 60px; border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #fff, #bbb 60%, #555);
            box-shadow: 0 4px 8px rgba(0,0,0,0.6); position: relative;
            transform: rotate(0deg); transition: transform 0.1s cubic-bezier(0.1, 0.7, 1.0, 0.1);
        }
        .knob::after {
            content: ''; position: absolute; top: 5px; left: 50%;
            transform: translateX(-50%); width: 4px; height: 12px;
            background-color: #333; border-radius: 2px;
        }
        .knurled { border: 2px dashed #666; }

        .mic-grille {
            width: 60px; height: 60px;
            background: radial-gradient(black 15%, transparent 16%) 0 0,
                radial-gradient(black 15%, transparent 16%) 8px 8px,
                radial-gradient(rgba(255,255,255,.1) 15%, transparent 20%) 0 1px,
                radial-gradient(rgba(255,255,255,.1) 15%, transparent 20%) 8px 9px;
            background-color: #222; background-size: 8px 8px; border-radius: 50%; border: 2px solid #444;
            box-shadow: inset 0 2px 6px rgba(0,0,0,0.8); display: flex; justify-content: center; align-items: center;
        }
        .mic-led {
            width: 8px; height: 8px; background-color: #300; border-radius: 50%;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.5); transition: background-color 0.1s;
        }
        .mic-led.active { background-color: #f00; box-shadow: 0 0 5px #f00; }

        /* --- Mid: Looper Controls --- */
        .mid-section {
            flex: 1.5; display: flex; flex-direction: row; align-items: center;
            justify-content: center; gap: 30px; position: relative;
            border: 1px solid #333; background: rgba(0,0,0,0.2);
            border-radius: 8px; padding: 10px; margin-bottom: 10px;
        }
        .rec-btn {
            width: 90px; height: 90px; border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #ff6666, #cc0000);
            border: 4px solid #111; box-shadow: 0 6px 0 #500, 0 15px 20px rgba(0,0,0,0.6);
            position: relative; display: flex; justify-content: center; align-items: center;
            transition: transform 0.1s; cursor: pointer; z-index: 10;
        }
        .rec-btn:active, .rec-btn.active-key { transform: translateY(4px); box-shadow: 0 2px 0 #500; }
        
        .undo-btn {
            width: 40px; height: 40px; border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #66ccff, #006699);
            border: 2px solid #111; color: #fff; font-size: 8px; font-weight: bold;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 4px 0 #003344, 0 5px 10px rgba(0,0,0,0.5);
            cursor: pointer; transition: all 0.1s;
        }
        .undo-btn:active { transform: translateY(2px); box-shadow: 0 2px 0 #003344; }
        .undo-btn.reset-flash { background: #fff; box-shadow: 0 0 20px #fff; }

        .rec-led-ring {
            width: 30px; height: 30px; border-radius: 50%; background-color: #300;
            box-shadow: inset 0 1px 4px rgba(0,0,0,0.8); transition: all 0.1s;
        }
        .rec-led-ring.standby { animation: flash-red 0.2s infinite alternate; background-color: #f00; }
        .rec-led-ring.recording { background-color: #f00; box-shadow: 0 0 15px #f00; }
        .rec-led-ring.playing { background-color: var(--led-green); box-shadow: 0 0 10px var(--led-green); }
        @keyframes flash-red { from { opacity: 0.2; } to { opacity: 1; } }
        @keyframes flash-white { 0% { background-color: #fff; color: #000; } 100% { background-color: #222; color: #555; } }
        .flash-trigger { animation: flash-white 0.2s ease-out; }
        .mid-labels {
            position: absolute; bottom: 5px; width: 100%; text-align: center;
            font-size: 9px; color: #555; pointer-events: none;
        }

        /* --- Modes --- */
        .mode-section { display: flex; justify-content: space-around; width: 100%; margin-bottom: 15px; }
        .mode-btn {
            background-color: #222; border: 1px solid #444; color: #555;
            padding: 8px 12px; border-radius: 4px; font-size: 10px; font-weight: bold;
            box-shadow: 0 2px 0 #000; width: 30%; text-align: center; cursor: pointer;
        }
        .mode-btn.active {
            background-color: #001122; color: var(--led-blue);
            border-color: var(--led-blue); box-shadow: 0 0 10px rgba(51, 204, 255, 0.2);
        }

        /* --- Pads --- */
        .pads-container {
            flex: 2; display: grid; grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(2, 1fr); gap: 8px; width: 100%;
        }
        .pad {
            background: rgba(255,255,255,0.05); border-radius: 6px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.8); transition: background 0.05s;
        }
        .pad.active { background: rgba(255, 200, 100, 0.4) !important; box-shadow: 0 0 15px rgba(255, 200, 100, 0.6) !important; }
        .pad.recording-armed { background-color: #500; border: 1px solid #f00; }
        .pad.recording { background-color: #f00; box-shadow: 0 0 15px #f00; }
        
        /* Sample Visuals - Only visible in Voice Mode */
        .mode-voice .pad.has-sample { 
            border: 1px solid var(--led-blue); 
            box-shadow: 0 0 5px var(--led-blue); 
            background: rgba(51, 204, 255, 0.1);
        }

        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            text-align: center; color: var(--accent-gold); padding: 20px;
        }
        #overlay button {
            margin-top: 20px; padding: 15px 30px; background: var(--accent-gold);
            border: none; font-weight: bold; font-size: 16px; cursor: pointer;
        }
        #status-log {
            position: absolute; bottom: 5px; left: 0; width: 100%;
            text-align: center; font-size: 10px; color: #666; pointer-events: none;
        }
    </style>
</head>
<body oncontextmenu="return false;">

<!-- Desktop Instructions -->
<div id="desktop-instructions">
    <h3>USER MANUAL</h3>
    <p><strong>CONTROLS</strong></p>
    <ul>
        <li><span>LOOP</span> <strong>Hold REC, Play</strong></li>
        <li><span>OVERDUB</span> <strong>Hold REC, Play</strong></li>
        <li><span>VOICE SAMPLE</span> <strong>Hold PAD + REC</strong></li>
        <li><span>DELETE SAMPLE</span> <strong>Hold PAD + UNDO</strong></li>
        <li><span>CLEAR ALL</span> <strong>Hold UNDO</strong></li>
    </ul>
    <p><strong>KNOBS</strong></p>
    <ul>
        <li><span>FX</span> <strong>Reverb (L) / Delay (R)</strong></li>
        <li><span>SPEED</span> <strong>Slow (L) / Fast (R)</strong></li>
    </ul>
    <p><strong>SHORTCUTS</strong></p>
    <ul>
        <li><span>REC</span> <strong>SHIFT</strong></li>
        <li><span>PADS (TOP)</span> <strong>Q W E R</strong></li>
        <li><span>PADS (BOT)</span> <strong>A S D F</strong></li>
        <li><span>POWER</span> <strong>SPACE</strong></li>
    </ul>
</div>

<div id="device">
    <div class="power-switch-container" id="power-switch">
        <div class="power-nub"></div>
    </div>

    <div class="top-section">
        <div class="knob-container">
            <div class="knob-label">EFFECTS</div>
            <div class="knob knurled" id="knob-glitch"></div>
        </div>
        <div class="mic-grille">
            <div class="mic-led" id="mic-led"></div>
        </div>
        <div class="knob-container">
            <div class="knob-label">SPEED</div>
            <div class="knob knurled" id="knob-speed"></div>
        </div>
    </div>

    <div class="mid-section">
        <div class="rec-btn" id="btn-rec">
            <div class="rec-led-ring" id="rec-led"></div>
        </div>
        <div class="undo-btn" id="btn-undo">UNDO</div>
        <div class="mid-labels">HOLD RED: REC / BLUE: CLEAR</div>
    </div>

    <div class="mode-section">
        <div class="mode-btn" data-mode="synth" id="btn-synth">SYNTH</div>
        <div class="mode-btn" data-mode="voice" id="btn-voice">VOICE</div>
        <div class="mode-btn active" data-mode="drums" id="btn-drums">DRUMS</div>
    </div>

    <div class="pads-container" id="pads-grid"></div>
    <div id="status-log"></div>
</div>

<div id="overlay">
    <h2>FOREST'S POCKET JAMS</h2>
    <p>Version 11.0</p>
    
        <p style="font-size: 12px; color: #ffffff; margin-top: 10px;">
 
        <span>LOOP:</span> <strong>Hold REC, Play</strong><br>
        <span>OVERDUB:</span> <strong>Hold REC, Play</strong><br>
        <span>VOICE SAMPLE:</span> <strong>Hold PAD + REC</strong><br>
        <span>DELETE SAMPLE:</span> <strong>Hold PAD + UNDO</strong><br>
        <span>CLEAR ALL:</span> <strong>Hold UNDO</strong><br>

    </p>
    <p style="font-size: 12px; color: #888; margin-top: 10px;">
        Headphones Recommended.<br>
        Microphone Access Required.
    </p>
    <button id="start-btn">POWER ON</button>
</div>

<script>
/**
 * FOREST'S POCKET JAMROOM - CORE LOGIC
 */

const AudioContext = window.AudioContext || window.webkitAudioContext;
let ctx;
let masterGain, compressor;
let analyser;
let micStream, micNode;

// Dual Bus System
let instBus, micBus; // Buses
let micGateGain;     // Input Gate for Mic
let instFXReturn, micFXReturn; // FX Outputs

// FX Nodes
let reverbBuffer = null;
let instReverb, instDelay, instFeedback, instDelayGain;
let micReverb, micDelay, micFeedback, micDelayGain;

const STATE = { IDLE: 0, ARMED: 1, RECORDING_1: 2, PLAYING: 3, OVERDUB: 4, SAMPLING_ARMED: 5, SAMPLING_REC: 6 };
let currentState = STATE.IDLE;
let currentMode = 'drums';
let lastInstrumentMode = 'drums'; 
let isPowered = true;

const DRUM_STYLES = ['Standard', '808', 'Acoustic', 'Industrial', 'Toy'];
const SYNTH_STYLES = ['Saw Lead', 'Bass', 'Soft Sine', 'Retro Pad', 'Pluck'];
let currentDrumIdx = 0; let currentSynthIdx = 0;
const DRUM_PADS = ['kick', 'snare', 'hat', 'tom', 'clap', 'perc1', 'perc2', 'crash'];
const SYNTH_NOTES = [261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88, 523.25];

let loopBuffer = null; let loopSource = null; let recBuffer = [];    
let loopStartTime = 0; let loopLengthSamples = 0;
let inputThreshold = 0.005;
let undoStack = []; let undoTimeout; let hasReset = false;
let minLoopLength = 2000;
const LATENCY_COMPENSATION_SAMPLES = 5120; 

let userSamples = new Array(8).fill(null);
let heldPadIndex = -1;
let sampleRecBuffer = [];

let playbackRate = 1.0;
let recStartTime = 0;

// UI
const els = {
    knobSpeed: document.getElementById('knob-speed'),
    knobGlitch: document.getElementById('knob-glitch'), 
    recBtn: document.getElementById('btn-rec'),
    recLed: document.getElementById('rec-led'),
    undoBtn: document.getElementById('btn-undo'),
    micLed: document.getElementById('mic-led'),
    overlay: document.getElementById('overlay'),
    startBtn: document.getElementById('start-btn'),
    padsGrid: document.getElementById('pads-grid'),
    modes: document.querySelectorAll('.mode-btn'),
    status: document.getElementById('status-log'),
    device: document.getElementById('device'),
    powerSwitch: document.getElementById('power-switch')
};

function log(msg) {
    els.status.innerText = msg;
    setTimeout(() => { if(els.status.innerText === msg) els.status.innerText = ''; }, 2000);
}

// Mobile Pinch Prevent
document.addEventListener('gesturestart', function(e) { e.preventDefault(); });
document.addEventListener('gesturechange', function(e) { e.preventDefault(); });
document.addEventListener('gestureend', function(e) { e.preventDefault(); });

els.startBtn.addEventListener('click', async () => {
    try {
        ctx = new AudioContext();
        await ctx.resume();
        
        compressor = ctx.createDynamicsCompressor();
        compressor.threshold.value = -12;
        compressor.ratio.value = 12;
        masterGain = ctx.createGain();
        masterGain.gain.value = 0.9;
        compressor.connect(masterGain);
        masterGain.connect(ctx.destination);

        setupDualFX();

        analyser = ctx.createAnalyser();
        analyser.fftSize = 256;

        try {
            micStream = await navigator.mediaDevices.getUserMedia({ audio: { 
                echoCancellation: false, noiseSuppression: false, autoGainControl: false, latency: 0 
            }});
            micNode = ctx.createMediaStreamSource(micStream);
            micNode.connect(analyser); 
            
            micGateGain = ctx.createGain();
            micGateGain.gain.value = 0; 
            micNode.connect(micGateGain);
            micGateGain.connect(micBus);
            
        } catch (e) { console.warn("Mic access denied."); }

        initUI(); initPads(); setupKeys();
        requestAnimationFrame(updateLoop);
        els.overlay.style.display = 'none';
        els.powerSwitch.classList.add('power-active'); 
        setupRecorder();
        
    } catch (e) { alert("Audio Init Failed: " + e); }
});

function setupDualFX() {
    reverbBuffer = createReverbBuffer();

    instBus = ctx.createGain(); instFXReturn = ctx.createGain(); instBus.connect(instFXReturn); 
    instReverb = ctx.createConvolver(); instReverb.buffer = reverbBuffer;
    let irGain = ctx.createGain(); irGain.gain.value = 0; instReverb.gainNode = irGain;
    instBus.connect(instReverb); instReverb.connect(irGain); irGain.connect(instFXReturn);
    instDelay = ctx.createDelay(1.0); instDelay.delayTime.value = 0.3;
    instFeedback = ctx.createGain(); instFeedback.gain.value = 0.3;
    instDelayGain = ctx.createGain(); instDelayGain.gain.value = 0;
    instBus.connect(instDelay); instDelay.connect(instFeedback); instFeedback.connect(instDelay);
    instDelay.connect(instDelayGain); instDelayGain.connect(instFXReturn);
    instFXReturn.connect(compressor);

    micBus = ctx.createGain(); micFXReturn = ctx.createGain(); micBus.connect(micFXReturn);
    micReverb = ctx.createConvolver(); micReverb.buffer = reverbBuffer;
    let mrGain = ctx.createGain(); mrGain.gain.value = 0; micReverb.gainNode = mrGain;
    micBus.connect(micReverb); micReverb.connect(mrGain); mrGain.connect(micFXReturn);
    micDelay = ctx.createDelay(1.0); micDelay.delayTime.value = 0.3;
    micFeedback = ctx.createGain(); micFeedback.gain.value = 0.3;
    micDelayGain = ctx.createGain(); micDelayGain.gain.value = 0;
    micBus.connect(micDelay); micDelay.connect(micFeedback); micFeedback.connect(micDelay);
    micDelay.connect(micDelayGain); micDelayGain.connect(micFXReturn);
}

function createReverbBuffer() {
    const len = ctx.sampleRate * 2.0; 
    const buffer = ctx.createBuffer(2, len, ctx.sampleRate);
    for (let c = 0; c < 2; c++) {
        const data = buffer.getChannelData(c);
        for (let i = 0; i < len; i++) data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / len, 3);
    }
    return buffer;
}

// --- Sound Engine ---
function playDrum(type) {
    const t = ctx.currentTime; const osc = ctx.createOscillator(); const gain = ctx.createGain();
    osc.connect(gain); gain.connect(instBus);
    const style = DRUM_STYLES[currentDrumIdx];
    if(type === 'kick') {
        osc.frequency.setValueAtTime(150, t);
        if(style === '808') { osc.frequency.exponentialRampToValueAtTime(30, t + 0.8); gain.gain.setValueAtTime(1, t); gain.gain.exponentialRampToValueAtTime(0.01, t + 0.8); }
        else if (style === 'Toy') { osc.frequency.setValueAtTime(250, t); osc.frequency.exponentialRampToValueAtTime(100, t + 0.1); osc.type = 'square'; gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1); }
        else if (style === 'Industrial') { osc.type = 'sawtooth'; osc.frequency.exponentialRampToValueAtTime(10, t + 0.3); }
        else { osc.frequency.exponentialRampToValueAtTime(0.01, t + 0.5); gain.gain.exponentialRampToValueAtTime(0.01, t + 0.5); }
        osc.start(t); osc.stop(t + 0.8);
    } else if(type === 'snare') {
        osc.type = 'triangle'; osc.frequency.setValueAtTime(250, t); gain.gain.setValueAtTime(0.5, t); gain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
        osc.start(t); osc.stop(t + 0.2); let noiseLen = (style === '808') ? 0.4 : 0.2; makeNoise(noiseLen, 0.8, t);
    } else if(type === 'hat') { makeNoise((style === '808')?0.05:0.1, 0.4, t, true); }
    else if(type === 'tom') { osc.frequency.setValueAtTime(200, t); osc.frequency.exponentialRampToValueAtTime(50, t + 0.4); gain.gain.setValueAtTime(0.8, t); gain.gain.exponentialRampToValueAtTime(0.01, t + 0.4); osc.start(t); osc.stop(t + 0.4); }
    else { makeNoise(0.1, 0.5, t); }
}

function makeNoise(duration, vol, time, highpass = false) {
    const bufferSize = ctx.sampleRate * duration; const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = buffer.getChannelData(0); for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
    const noise = ctx.createBufferSource(); noise.buffer = buffer; const noiseGain = ctx.createGain();
    noiseGain.gain.setValueAtTime(vol, time); noiseGain.gain.exponentialRampToValueAtTime(0.01, time + duration);
    noise.connect(noiseGain); const dest = highpass ? ctx.createBiquadFilter() : instBus; 
    if(highpass) { dest.type = 'highpass'; dest.frequency.value = 5000; noiseGain.connect(dest); dest.connect(instBus); } 
    else { noiseGain.connect(instBus); } noise.start(time);
}

function playSynth(freq) {
    const t = ctx.currentTime; const osc = ctx.createOscillator(); const filter = ctx.createBiquadFilter(); const gain = ctx.createGain();
    const style = SYNTH_STYLES[currentSynthIdx]; osc.frequency.value = freq; filter.type = 'lowpass'; filter.Q.value = 1; let duration = 0.5;
    if(style === 'Saw Lead') { osc.type = 'sawtooth'; filter.frequency.setValueAtTime(300, t); filter.frequency.exponentialRampToValueAtTime(4000, t + 0.05); filter.frequency.exponentialRampToValueAtTime(300, t + 0.5); gain.gain.setValueAtTime(0, t); gain.gain.linearRampToValueAtTime(0.4, t + 0.02); gain.gain.exponentialRampToValueAtTime(0.01, t + 0.5); }
    else if (style === 'Bass') { osc.type = 'square'; osc.frequency.value = freq / 2; filter.frequency.setValueAtTime(800, t); filter.frequency.exponentialRampToValueAtTime(100, t + 0.3); gain.gain.setValueAtTime(0.6, t); gain.gain.exponentialRampToValueAtTime(0.01, t + 0.4); }
    else if (style === 'Soft Sine') { osc.type = 'sine'; filter.frequency.value = 2000; gain.gain.setValueAtTime(0, t); gain.gain.linearRampToValueAtTime(0.5, t + 0.1); gain.gain.linearRampToValueAtTime(0, t + 0.8); duration = 0.8; }
    else if (style === 'Retro Pad') { osc.type = 'sawtooth'; filter.frequency.setValueAtTime(400, t); filter.frequency.linearRampToValueAtTime(1200, t + 0.5); gain.gain.setValueAtTime(0, t); gain.gain.linearRampToValueAtTime(0.3, t + 0.4); gain.gain.linearRampToValueAtTime(0, t + 1.0); duration = 1.0; }
    else if (style === 'Pluck') { osc.type = 'triangle'; filter.frequency.setValueAtTime(3000, t); filter.frequency.exponentialRampToValueAtTime(200, t + 0.2); gain.gain.setValueAtTime(0.5, t); gain.gain.exponentialRampToValueAtTime(0.01, t + 0.3); duration = 0.3; }
    osc.connect(filter); filter.connect(gain); gain.connect(instBus); osc.start(t); osc.stop(t + duration);
}

function playSample(index) {
    if(!userSamples[index]) return;
    const src = ctx.createBufferSource(); src.buffer = userSamples[index]; src.connect(instBus); src.start(0);
}

function isRecordingState() {
    return (currentState === STATE.RECORDING_1 || currentState === STATE.OVERDUB || currentState === STATE.ARMED || currentState === STATE.SAMPLING_ARMED || currentState === STATE.SAMPLING_REC);
}

// --- Recorder ---
const bufferSize = 4096;
let recorderNode;
let recordingStream = [];

function setupRecorder() {
    if(recorderNode) return;
    recorderNode = ctx.createScriptProcessor(bufferSize, 1, 1);
    recorderNode.onaudioprocess = (e) => {
        if (!isRecordingState()) return;
        const input = e.inputBuffer.getChannelData(0);
        
        if (currentState === STATE.SAMPLING_ARMED) {
            let sum = 0; for(let i=0; i<input.length; i++) sum += input[i]*input[i];
            if(Math.sqrt(sum/input.length) > inputThreshold) {
                currentState = STATE.SAMPLING_REC; sampleRecBuffer = [];
                if (heldPadIndex !== -1) {
                    const pad = els.padsGrid.children[heldPadIndex];
                    if(pad) { pad.classList.remove('recording-armed'); pad.classList.add('recording'); }
                }
                log("SAMPLING..."); updateMicGate(); 
            } else { return; }
        }

        if (currentState === STATE.SAMPLING_REC) { sampleRecBuffer.push(new Float32Array(input)); return; }

        if (currentState === STATE.ARMED) {
            let sum = 0; for(let i=0; i<input.length; i++) sum += input[i]*input[i];
            if(Math.sqrt(sum/input.length) > inputThreshold) startFirstRecording(); else return;
        }
        
        if (currentState === STATE.RECORDING_1 || currentState === STATE.OVERDUB) recordingStream.push(new Float32Array(input));
        
        const output = e.outputBuffer.getChannelData(0); for (let i = 0; i < output.length; i++) output[i] = 0; 
    };
    instFXReturn.connect(recorderNode); micFXReturn.connect(recorderNode);
    const zeroGain = ctx.createGain(); zeroGain.gain.value = 0; recorderNode.connect(zeroGain); zeroGain.connect(ctx.destination);
}

// --- Control Logic ---
function onRecPress() {
    if(!isPowered) return;
    if (currentMode === 'voice' && heldPadIndex !== -1) {
        currentState = STATE.SAMPLING_ARMED; sampleRecBuffer = [];
        const pad = els.padsGrid.children[heldPadIndex];
        if(pad) pad.classList.add('recording-armed');
        log("ARMED: SPEAK"); updateMicGate(); return;
    }
    if (currentState === STATE.IDLE) {
        currentState = STATE.ARMED; els.recLed.className = 'rec-led-ring standby'; recordingStream = []; 
        log("ARMED: MAKE SOUND"); updateMicGate();
    } else if (currentState === STATE.PLAYING) startOverdub();
}

function onRecRelease() {
    if (currentState === STATE.SAMPLING_REC || currentState === STATE.SAMPLING_ARMED) finishSampling();
    else if (currentState === STATE.RECORDING_1) finishFirstLoop();
    else if (currentState === STATE.ARMED) { currentState = STATE.IDLE; els.recLed.className = 'rec-led-ring'; log("CANCELLED"); updateMicGate(); }
    else if (currentState === STATE.OVERDUB) stopOverdub();
}

function finishSampling() {
    if (currentState === STATE.SAMPLING_REC && sampleRecBuffer.length > 0) {
        const totalSamples = sampleRecBuffer.length * bufferSize;
        const rawBuffer = ctx.createBuffer(1, totalSamples, ctx.sampleRate);
        const data = rawBuffer.getChannelData(0); let offset = 0;
        for(let chunk of sampleRecBuffer) { data.set(chunk, offset); offset += chunk.length; }
        const trim = LATENCY_COMPENSATION_SAMPLES; 
        if(totalSamples > trim) {
            const trimmedBuffer = ctx.createBuffer(1, totalSamples - trim, ctx.sampleRate);
            trimmedBuffer.copyToChannel(data.subarray(trim), 0);
            userSamples[heldPadIndex] = trimmedBuffer;
        } else { userSamples[heldPadIndex] = rawBuffer; }
        log("SAMPLE SAVED");
    } else { log("SAMPLE CANCELLED"); }
    const pad = els.padsGrid.children[heldPadIndex];
    if(pad) { pad.classList.remove('recording'); pad.classList.remove('recording-armed'); }
    currentState = (loopBuffer !== null) ? STATE.PLAYING : STATE.IDLE; updateMicGate(); updatePadVisuals();
}

function startFirstRecording() {
    currentState = STATE.RECORDING_1; els.recLed.className = 'rec-led-ring recording';
    recordingStream = []; recStartTime = ctx.currentTime; log("RECORDING..."); updateMicGate();
}

function finishFirstLoop() {
    const totalSamples = recordingStream.length * bufferSize;
    if(totalSamples < minLoopLength) { currentState = STATE.IDLE; els.recLed.className = 'rec-led-ring'; log("TOO SHORT"); updateMicGate(); return; }
    currentState = STATE.PLAYING; els.recLed.className = 'rec-led-ring playing'; undoStack.push('RESET');
    const rawBuffer = ctx.createBuffer(1, totalSamples, ctx.sampleRate); const data = rawBuffer.getChannelData(0); let offset = 0;
    for(let chunk of recordingStream) { data.set(chunk, offset); offset += chunk.length; }
    loopBuffer = rawBuffer; loopLengthSamples = totalSamples; startPlayback(); log("LOOPING"); updateMicGate();
}

function startOverdub() {
    if(!loopBuffer) return;
    saveUndoState(); currentState = STATE.OVERDUB; els.recLed.className = 'rec-led-ring recording';
    recordingStream = []; recStartTime = ctx.currentTime; log("DUBBING..."); updateMicGate();
}

function stopOverdub() {
    currentState = STATE.PLAYING; els.recLed.className = 'rec-led-ring playing'; log("PLAYING"); updateMicGate();
    if(!loopBuffer || recordingStream.length === 0) return;
    const oldData = loopBuffer.getChannelData(0); const loopTotalSamples = loopBuffer.length;
    
    // Stable calculation based on time elapsed
    let timeElapsed = ctx.currentTime - loopStartTime;
    // Current pos is simply time * rate. If negative, it wraps.
    let currentLoopPos = (timeElapsed * ctx.sampleRate * playbackRate) % loopTotalSamples;
    
    // Normalize position
    while(currentLoopPos < 0) currentLoopPos += loopTotalSamples;
    while(currentLoopPos >= loopTotalSamples) currentLoopPos -= loopTotalSamples;

    // Latency compensation
    currentLoopPos -= (playbackRate * LATENCY_COMPENSATION_SAMPLES);
    while(currentLoopPos < 0) currentLoopPos += loopTotalSamples;
    while(currentLoopPos >= loopTotalSamples) currentLoopPos -= loopTotalSamples;

    const flatRecLen = recordingStream.length * bufferSize;
    const flatRec = new Float32Array(flatRecLen);
    let off = 0;
    for(let chunk of recordingStream) { flatRec.set(chunk, off); off += chunk.length; }
    
    for (let i = 0; i < flatRecLen; i++) {
        const inputSample = flatRec[flatRecLen - 1 - i];
        let targetIndex = currentLoopPos - (i * playbackRate);
        
        while(targetIndex < 0) targetIndex += loopTotalSamples;
        while(targetIndex >= loopTotalSamples) targetIndex -= loopTotalSamples;
        
        oldData[Math.floor(targetIndex)] += inputSample;
    }
}

function startPlayback() {
    if(loopSource) { try { loopSource.stop(); } catch(e){} }
    loopSource = ctx.createBufferSource(); loopSource.buffer = loopBuffer; loopSource.loop = true;
    
    // REVERSE FIX: Explicit loop points mandatory for Desktop
    loopSource.loopStart = 0;
    loopSource.loopEnd = loopBuffer.duration;
    
    loopSource.playbackRate.value = playbackRate;
    loopSource.connect(compressor);
    loopStartTime = ctx.currentTime;
    loopSource.start(0);
}

// --- UI Logic ---
function initPads() {
    els.padsGrid.innerHTML = '';
    for(let i=0; i<8; i++) {
        const btn = document.createElement('div'); btn.className = 'pad';
        btn.addEventListener('pointerdown', (e) => { 
            e.preventDefault(); if(!isPowered) return;
            btn.setPointerCapture(e.pointerId); heldPadIndex = i; btn.classList.add('active'); hitPad(i, btn); 
        });
        btn.addEventListener('pointerup', (e) => { heldPadIndex = -1; btn.classList.remove('active'); btn.releasePointerCapture(e.pointerId); });
        btn.addEventListener('pointercancel', (e) => { heldPadIndex = -1; btn.classList.remove('active'); btn.releasePointerCapture(e.pointerId); });
        els.padsGrid.appendChild(btn);
    }
}

function updatePadVisuals() {
    const pads = Array.from(els.padsGrid.children);
    pads.forEach((pad, i) => {
        pad.classList.remove('has-sample');
        if (currentMode === 'voice' && userSamples[i]) pad.classList.add('has-sample');
    });
    if(currentMode === 'voice') els.padsGrid.classList.add('mode-voice');
    else els.padsGrid.classList.remove('mode-voice');
}

function hitPad(index, el) {
    if (currentMode === 'voice') {
        if (userSamples[index]) playSample(index);
    } else {
        if (currentMode === 'drums') playDrum(DRUM_PADS[index]);
        else if (currentMode === 'synth') playSynth(SYNTH_NOTES[index]);
    }
}

function updateMicGate() {
    if(!micGateGain) return;
    const isVoiceMode = (currentMode === 'voice');
    const isRecording = (currentState === STATE.RECORDING_1 || currentState === STATE.OVERDUB || currentState === STATE.SAMPLING_REC || currentState === STATE.ARMED || currentState === STATE.SAMPLING_ARMED);
    if(isVoiceMode) {
        if(isRecording) micGateGain.gain.setTargetAtTime(1.0, ctx.currentTime, 0.05); 
        else micGateGain.gain.setTargetAtTime(0.0, ctx.currentTime, 0.05); 
    } else { micGateGain.gain.setTargetAtTime(0.0, ctx.currentTime, 0.05); }
}

function initUI() {
    els.modes.forEach(btn => {
        btn.addEventListener('click', (e) => {
            if(!isPowered) return;
            const newMode = btn.dataset.mode;
            if(btn.classList.contains('active')) {
                if(newMode === 'drums') { currentDrumIdx = (currentDrumIdx + 1) % DRUM_STYLES.length; log("DRUMS: " + DRUM_STYLES[currentDrumIdx]); } 
                else if(newMode === 'synth') { currentSynthIdx = (currentSynthIdx + 1) % SYNTH_STYLES.length; log("SYNTH: " + SYNTH_STYLES[currentSynthIdx]); }
                btn.classList.add('flash-trigger'); setTimeout(()=>btn.classList.remove('flash-trigger'), 200); return;
            }
            els.modes.forEach(b => b.classList.remove('active')); btn.classList.add('active');
            if(currentMode !== 'voice') lastInstrumentMode = currentMode;
            currentMode = newMode; log("MODE: " + currentMode.toUpperCase());
            updatePadVisuals(); updateMicGate();
        });
    });

    els.recBtn.addEventListener('pointerdown', (e) => { if(!isPowered) return; e.preventDefault(); els.recBtn.setPointerCapture(e.pointerId); onRecPress(); });
    els.recBtn.addEventListener('pointerup', (e) => { e.preventDefault(); onRecRelease(); els.recBtn.releasePointerCapture(e.pointerId); });
    els.recBtn.addEventListener('pointercancel', (e) => { onRecRelease(); els.recBtn.releasePointerCapture(e.pointerId); });
    els.powerSwitch.addEventListener('click', togglePower);

    setupKnob(els.knobSpeed, (val) => {
        if(!isPowered) return;
        if (val > 0.45 && val < 0.55) { playbackRate = 1.0; }
        else if (val >= 0.55) { if (val < 0.9) { playbackRate = 1.0 + ((val-0.55)/0.35)*1.5; } else { playbackRate = -2.0; } } 
        else if (val <= 0.45) { playbackRate = 1.0 - ((0.45 - val) / 0.225); }
        
        // Prevent pure 0.0 to fix reverse playback issues on desktop
        if (Math.abs(playbackRate) < 0.001) playbackRate = 0.001;

        if(loopSource) {
            // Force parameter update to help browser catch up
            loopSource.playbackRate.value = playbackRate;
        }
    }, true); 

    setupKnob(els.knobGlitch, (val) => {
        if(!isPowered || !instReverb) return;
        let rGain, dGain, dFeed;
        if (val > 0.45 && val < 0.55) { rGain=0; dGain=0; dFeed=0; }
        else if (val >= 0.55) { rGain=0; const norm = (val-0.55)/0.45; dGain=norm*0.8; dFeed=0.2+(norm*0.5); } 
        else if (val <= 0.45) { dGain=0; dFeed=0; const norm = (0.45-val)/0.45; rGain=norm*1.5; }
        instReverb.gainNode.gain.value = rGain; micReverb.gainNode.gain.value = rGain;
        instDelayGain.gain.value = dGain; micDelayGain.gain.value = dGain;
        instFeedback.gain.value = dFeed; micFeedback.gain.value = dFeed;
    }, true);
}

function togglePower() {
    isPowered = !isPowered;
    if(isPowered) { els.powerSwitch.classList.add('power-active'); els.device.classList.remove('powered-off'); ctx.resume(); log("RESUME"); } 
    else { els.powerSwitch.classList.remove('power-active'); els.device.classList.add('powered-off'); ctx.suspend(); }
}

function setupKnob(el, callback, magnet = false) {
    let startY = 0; let currentDeg = 0;
    const update = (y) => {
        const delta = startY - y; currentDeg += delta * 2; currentDeg = Math.min(135, Math.max(-135, currentDeg));
        let visualDeg = currentDeg; if (magnet && Math.abs(currentDeg) < 15) visualDeg = 0;
        el.style.transform = `rotate(${visualDeg}deg)`; callback((visualDeg + 135) / 270); startY = y;
    };
    el.addEventListener('pointerdown', e => { if(!isPowered) return; startY = e.clientY; el.setPointerCapture(e.pointerId);
        const move = e => update(e.clientY);
        const up = () => { el.removeEventListener('pointermove', move); el.removeEventListener('pointerup', up); el.releasePointerCapture(e.pointerId); };
        el.addEventListener('pointermove', move); el.addEventListener('pointerup', up);
    });
}

function updateLoop() {
    if(isPowered) {
        if (analyser) {
            const data = new Uint8Array(analyser.frequencyBinCount); analyser.getByteFrequencyData(data);
            let sum = 0; for(let v of data) sum += v;
            if ((sum/data.length) > 10) els.micLed.classList.add('active'); else els.micLed.classList.remove('active');
        }
    } else { els.micLed.classList.remove('active'); }
    requestAnimationFrame(updateLoop);
}

// Shortcuts
function setupKeys() {
    const padKeys = { 'q':0, 'w':1, 'e':2, 'r':3, 'a':4, 's':5, 'd':6, 'f':7 };
    let recKeyDown = false;
    window.addEventListener('keydown', (e) => {
        if(!isPowered) return;
        if(e.repeat) return;
        const k = e.key.toLowerCase();
        if(k in padKeys) {
            const idx = padKeys[k]; heldPadIndex = idx;
            const btn = els.padsGrid.children[idx];
            if(btn) { btn.classList.add('active'); hitPad(idx, btn); }
        }
        if(e.key === 'Shift') { if(!recKeyDown) { recKeyDown = true; els.recBtn.classList.add('active-key'); onRecPress(); } }
        if(e.key === ' ') { e.preventDefault(); togglePower(); }
    });
    window.addEventListener('keyup', (e) => {
        if(!isPowered) return;
        const k = e.key.toLowerCase();
        if(k in padKeys) {
            const idx = padKeys[k]; heldPadIndex = -1;
            const btn = els.padsGrid.children[idx]; if(btn) btn.classList.remove('active');
        }
        if(e.key === 'Shift') { recKeyDown = false; els.recBtn.classList.remove('active-key'); onRecRelease(); }
    });
}

// Undo
els.undoBtn.addEventListener('pointerdown', startUndoTimer);
els.undoBtn.addEventListener('pointerup', endUndoTimer);
els.undoBtn.addEventListener('pointercancel', endUndoTimer);

function startUndoTimer(e) { if(!isPowered) return; els.undoBtn.setPointerCapture(e.pointerId); hasReset = false; undoTimeout = setTimeout(resetDevice, 1000); }
function endUndoTimer(e) { clearTimeout(undoTimeout); if (!hasReset && isPowered) performUndo(); }
function saveUndoState() { if(!loopBuffer) return; const copy = new Float32Array(loopBuffer.getChannelData(0)); undoStack.push(copy); if(undoStack.length > 5) undoStack.shift(); }
function performUndo() {
    // Delete Sample
    if(currentMode === 'voice' && heldPadIndex !== -1) {
        if(userSamples[heldPadIndex]) { userSamples[heldPadIndex] = null; updatePadVisuals(); log("SAMPLE DELETED"); return; }
    }
    // Undo Loop
    if(undoStack.length > 0 && loopBuffer) {
        const prev = undoStack.pop();
        if(prev === 'RESET') resetDevice();
        else { loopBuffer.copyToChannel(prev, 0); log("UNDO LAYER"); els.undoBtn.style.color = '#000'; setTimeout(()=>els.undoBtn.style.color = '#fff', 200); }
    } else log("EMPTY");
}
function resetDevice() {
    hasReset = true; if(loopSource) loopSource.stop();
    loopBuffer = null; loopSource = null; recordingStream = []; undoStack = [];
    // NOTE: userSamples NOT cleared on reset, per request
    currentState = STATE.IDLE; els.recLed.className = 'rec-led-ring';
    els.undoBtn.classList.add('reset-flash'); setTimeout(() => els.undoBtn.classList.remove('reset-flash'), 500);
    log("RESET LOOP");
}
</script>
</body>
</html>