<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Forest's Pocket Jams v12</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --plate-color: #222;
            --fr4-color: #2a2a2a;
            --led-off: #331111;
            --led-red: #ff3333;
            --led-green: #33ff33;
            --led-blue: #33ccff;
            --accent-gold: #c5a059;
            --knob-silver: #ddd;
        }

        * { 
            box-sizing: border-box; 
            touch-action: none; 
            -webkit-tap-highlight-color: transparent; 
            user-select: none; 
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }
        
        html, body {
            margin: 0;
            padding: 0;
            background-color: #000;
            color: #eee;
            font-family: 'Courier New', Courier, monospace;
            height: 100%;
            width: 100%;
            overflow: hidden;
            overscroll-behavior: none;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* --- Desktop Instructions --- */
        #desktop-instructions {
            position: fixed;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            width: 280px;
            max-width: 25vw;
            background: rgba(0,0,0,0.85);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #333;
            color: #ccc;
            font-size: 11px;
            line-height: 1.4;
            display: none; 
            pointer-events: none;
            z-index: 100;
            backdrop-filter: blur(4px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        
        #desktop-instructions h3 { 
            color: var(--accent-gold); 
            border-bottom: 1px solid #444; 
            padding-bottom: 8px; 
            margin: 0 0 12px 0; 
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        #desktop-instructions strong { color: #fff; }
        #desktop-instructions ul { padding-left: 0; list-style: none; margin: 0 0 15px 0; }
        #desktop-instructions li { margin-bottom: 6px; display: flex; justify-content: space-between; }
        #desktop-instructions li span:first-child { color: #888; }
        #desktop-instructions .section-title { color: var(--accent-gold); margin-top: 15px; margin-bottom: 5px; font-weight: bold; border-top: 1px solid #333; padding-top: 5px;}

        @media (min-width: 900px) {
            #desktop-instructions { display: block; }
        }

        /* --- Device --- */
        #device {
            width: 90vw;
            max-width: 380px;
            height: 90vh;
            max-height: 700px;
            background-color: var(--plate-color);
            border-radius: 20px;
            position: relative;
            box-shadow: 
                inset 0 0 20px rgba(0,0,0,0.9),
                0 0 0 4px #111,
                0 10px 30px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            padding: 20px;
            background-image: 
                linear-gradient(45deg, #252525 25%, transparent 25%, transparent 75%, #252525 75%, #252525), 
                linear-gradient(45deg, #252525 25%, transparent 25%, transparent 75%, #252525 75%, #252525);
            background-size: 4px 4px;
            background-position: 0 0, 2px 2px;
            transition: filter 0.3s;
            z-index: 10;
        }

        #device.powered-off { filter: brightness(0.4); }
        #device.powered-off .power-switch-container { filter: brightness(2.5); pointer-events: auto; }
        
        #device.powered-off .mic-led,
        #device.powered-off .rec-led-ring,
        #device.powered-off .pad.active,
        #device.powered-off .pad.has-sample {
            background-color: #111 !important;
            box-shadow: none !important;
            border-color: #333 !important;
            animation: none !important;
        }

        /* --- Power Switch --- */
        .power-switch-container {
            position: absolute; top: 140px; right: -12px; left: auto;
            width: 24px; height: 50px; background: #111;
            border: 2px solid #333; border-left: none; border-radius: 0 6px 6px 0;
            z-index: 50; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
        }
        .power-nub {
            width: 12px; height: 20px; background: #444; border-radius: 2px;
            box-shadow: inset 1px 1px 2px rgba(255,255,255,0.2);
            transform: translateY(-10px); transition: transform 0.2s, background-color 0.2s;
        }
        .power-active .power-nub {
            transform: translateY(10px); background-color: var(--accent-gold);
            box-shadow: 0 0 10px var(--accent-gold);
        }

        /* --- Top: Knobs --- */
        .top-section {
            flex: 1; display: flex; justify-content: space-between;
            align-items: center; padding: 10px 0; border-bottom: 2px solid #111; margin-bottom: 10px;
        }
        .knob-container { display: flex; flex-direction: column; align-items: center; width: 80px; }
        .knob-label { font-size: 10px; margin-bottom: 5px; color: #888; font-weight: bold; letter-spacing: 1px; }
        .knob {
            width: 60px; height: 60px; border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #fff, #bbb 60%, #555);
            box-shadow: 0 4px 8px rgba(0,0,0,0.6); position: relative;
            transform: rotate(0deg); transition: transform 0.1s cubic-bezier(0.1, 0.7, 1.0, 0.1);
        }
        .knob::after {
            content: ''; position: absolute; top: 5px; left: 50%;
            transform: translateX(-50%); width: 4px; height: 12px;
            background-color: #333; border-radius: 2px;
        }
        .knurled { border: 2px dashed #666; }

        .mic-grille {
            width: 60px; height: 60px;
            background: radial-gradient(black 15%, transparent 16%) 0 0,
                radial-gradient(black 15%, transparent 16%) 8px 8px,
                radial-gradient(rgba(255,255,255,.1) 15%, transparent 20%) 0 1px,
                radial-gradient(rgba(255,255,255,.1) 15%, transparent 20%) 8px 9px;
            background-color: #222; background-size: 8px 8px; border-radius: 50%; border: 2px solid #444;
            box-shadow: inset 0 2px 6px rgba(0,0,0,0.8); display: flex; justify-content: center; align-items: center;
        }
        .mic-led {
            width: 8px; height: 8px; background-color: #300; border-radius: 50%;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.5); transition: background-color 0.1s;
        }
        .mic-led.active { background-color: #f00; box-shadow: 0 0 5px #f00; }

        /* --- Mid: Looper Controls --- */
        .mid-section {
            flex: 1.5; display: flex; flex-direction: row; align-items: center;
            justify-content: center; gap: 30px; position: relative;
            border: 1px solid #333; background: rgba(0,0,0,0.2);
            border-radius: 8px; padding: 10px; margin-bottom: 10px;
        }
        .rec-btn {
            width: 100px; height: 100px; border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #ff6666, #cc0000);
            border: 4px solid #111; box-shadow: 0 6px 0 #500, 0 15px 20px rgba(0,0,0,0.6);
            position: relative; display: flex; justify-content: center; align-items: center;
            transition: transform 0.1s; cursor: pointer; z-index: 10;
        }
        .rec-btn:active, .rec-btn.active-key { transform: translateY(4px); box-shadow: 0 2px 0 #500; }
        
        .undo-btn {
            width: 40px; height: 40px; border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #66ccff, #006699);
            border: 2px solid #111; color: #fff; font-size: 8px; font-weight: bold;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 4px 0 #003344, 0 5px 10px rgba(0,0,0,0.5);
            cursor: pointer; transition: all 0.1s;
        }
        .undo-btn:active, .undo-btn.active-key { transform: translateY(2px); box-shadow: 0 2px 0 #003344; }
        .undo-btn.reset-flash { background: #fff; box-shadow: 0 0 20px #fff; }

        .rec-led-ring {
            width: 30px; height: 30px; border-radius: 50%; background-color: #300;
            box-shadow: inset 0 1px 4px rgba(0,0,0,0.8); transition: all 0.1s;
        }
        .rec-led-ring.standby { animation: flash-red 0.2s infinite alternate; background-color: #f00; }
        .rec-led-ring.recording { background-color: #f00; box-shadow: 0 0 15px #f00; }
        .rec-led-ring.playing { background-color: var(--led-green); box-shadow: 0 0 10px var(--led-green); }
        @keyframes flash-red { from { opacity: 0.2; } to { opacity: 1; } }
        @keyframes flash-white { 0% { background-color: #fff; color: #000; } 100% { background-color: #222; color: #555; } }
        .flash-trigger { animation: flash-white 0.2s ease-out; }
        .mid-labels {
            position: absolute; bottom: 5px; width: 100%; text-align: center;
            font-size: 9px; color: #555; pointer-events: none;
        }

        /* --- Modes --- */
        .mode-section { display: flex; justify-content: space-around; width: 100%; margin-bottom: 15px; position: relative; }
        
        /* Scale Switch */
        .scale-switch-wrapper {
            position: absolute;
            top: -30px;
            left: 6%;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .scale-label { font-size: 8px; color: #666; font-weight: bold; }
        .scale-toggle {
            width: 30px; height: 14px; background: #111; border: 1px solid #444; border-radius: 10px;
            position: relative; cursor: pointer;
        }
        .scale-toggle::after {
            content: ''; position: absolute; top: 1px; left: 1px; width: 10px; height: 10px;
            background: #666; border-radius: 50%; transition: left 0.2s, background 0.2s;
        }
        .scale-toggle.minor::after { left: 17px; background: var(--accent-gold); }

        .mode-btn {
            background-color: #222; border: 1px solid #444; color: #555;
            padding: 8px 12px; border-radius: 4px; font-size: 10px; font-weight: bold;
            box-shadow: 0 2px 0 #000; width: 30%; text-align: center; cursor: pointer;
        }
        .mode-btn.active {
            background-color: #001122; color: var(--led-blue);
            border-color: var(--led-blue); box-shadow: 0 0 10px rgba(51, 204, 255, 0.2);
        }

        /* --- Pads --- */
        .pads-container {
            flex: 2; display: grid; grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(2, 1fr); gap: 8px; width: 100%;
        }
        .pad {
            background: rgba(255,255,255,0.05); border-radius: 6px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.8); transition: background 0.05s;
        }
        .pad.active { background: rgba(255, 200, 100, 0.4) !important; box-shadow: 0 0 15px rgba(255, 200, 100, 0.6) !important; }
        .pad.recording-armed { background-color: #500; border: 1px solid #f00; }
        .pad.recording { background-color: #f00; box-shadow: 0 0 15px #f00; }
        
        /* Sample Visuals - Only visible in Voice Mode */
        .mode-voice .pad.has-sample { 
            background: rgba(255, 50, 50, 0.1); /* Subtle red tint */
            border: 1px solid #ff3333;          /* Red Outline */
            box-shadow: 0 0 8px #ff3333;        /* Red Glow */
            animation: pulse-sample 2s infinite;
        }

        @keyframes pulse-sample {
            0% { box-shadow: 0 0 5px #ff3333; border-color: #aa3333; }
            50% { box-shadow: 0 0 10px #ff3333; border-color: #ff3333; }
            100% { box-shadow: 0 0 5px #ff3333; border-color: #aa3333; }
        }

        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            text-align: center; color: var(--accent-gold); padding: 20px;
        }
        #overlay button {
            margin-top: 20px; padding: 15px 30px; background: var(--accent-gold);
            border: none; font-weight: bold; font-size: 16px; cursor: pointer;
        }
        #status-log {
            position: absolute; bottom: 5px; left: 0; width: 100%;
            text-align: center; font-size: 10px; color: #666; pointer-events: none;
        }
    </style>
</head>
<body oncontextmenu="return false;">

<!-- Desktop Instructions -->
<div id="desktop-instructions">
    <h3>USER MANUAL v12</h3>
    <div class="section-title">BASICS</div>
    <ul>
        <li><span>LOOP</span> <strong>Hold REC + Play</strong></li>
        <li><span>OVERDUB</span> <strong>Hold REC + Play</strong></li>
        <li><span>VOICE SAMPLE</span> <strong>Hold PAD + REC</strong></li>
        <li><span>DELETE SAMPLE</span> <strong>Hold PAD + UNDO</strong></li>
        <li><span>CLEAR ALL</span> <strong>Hold UNDO</strong></li>
    </ul>
    
    <div class="section-title">KEYBOARD SHORTCUTS</div>
    <ul>
        <li><span>REC</span> <strong>SHIFT</strong></li>
        <li><span>UNDO</span> <strong>CTRL</strong></li>
        <li><span>INSTRUMENTS</span> <strong>1 / 2 / 3</strong></li>
        <li><span>PADS (TOP)</span> <strong>Q W E R</strong></li>
        <li><span>PADS (BOT)</span> <strong>A S D F</strong></li>
        <li><span>POWER</span> <strong>SPACE</strong></li>
    </ul>

    <div class="section-title">SOUND DESIGN</div>
    <ul>
        <li><span>CHANGE SOUND</span> <strong>Click Instrument Btn</strong></li>
        <li><span>SYNTH SCALE</span> <strong>Switch above Synth</strong></li>
        <li><span>FX KNOB</span> <strong>Reverb (L) / Delay (R)</strong></li>
        <li><span>SPEED KNOB</span> <strong>Slow (L) / Fast (R)</strong></li>
    </ul>
</div>

<div id="device">
    <div class="power-switch-container" id="power-switch">
        <div class="power-nub"></div>
    </div>

    <div class="top-section">
        <div class="knob-container">
            <div class="knob-label">EFFECTS</div>
            <div class="knob knurled" id="knob-glitch"></div>
        </div>
        <div class="mic-grille">
            <div class="mic-led" id="mic-led"></div>
        </div>
        <div class="knob-container">
            <div class="knob-label">SPEED</div>
            <div class="knob knurled" id="knob-speed"></div>
        </div>
    </div>

    <div class="mid-section">
        <div class="rec-btn" id="btn-rec">
            <div class="rec-led-ring" id="rec-led"></div>
        </div>
        <div class="undo-btn" id="btn-undo">UNDO</div>
    </div>

    <div class="mode-section">
        <div class="scale-switch-wrapper" id="scale-wrapper">
            <div class="scale-label">MAJ</div>
            <div class="scale-toggle" id="scale-switch"></div>
            <div class="scale-label">MIN</div>
        </div>

        <div class="mode-btn" data-mode="synth" id="btn-synth">SYNTH</div>
        <div class="mode-btn" data-mode="voice" id="btn-voice">VOICE</div>
        <div class="mode-btn active" data-mode="drums" id="btn-drums">DRUMS</div>
    </div>

    <div class="pads-container" id="pads-grid"></div>
    <div id="status-log"></div>
</div>

<div id="overlay">
    <h2>FOREST'S POCKET JAMS</h2>
    <p>Version 12.0</p>
    
        <p style="font-size: 11px; color: #ffffff; margin-top: 10px; line-height: 1.6;">
 
        <span>LOOP/DUB:</span> <strong>Hold REC, Play</strong><br>
        <span>VOICE SAMPLE:</span> <strong>Hold PAD + REC</strong><br>
        <span>UNDO:</span> <strong>Press UNDO (or Ctrl)</strong><br>
        <span>CLEAR ALL:</span> <strong>Hold UNDO (or Ctrl)</strong><br>
        <span style="color:#aaa; display:block; margin-top:5px; border-top:1px solid #444; padding-top:5px;">
        Tap Instrument Button to Cycle Sounds<br>
        Keys: 1=Synth, 2=Voice, 3=Drums
        </span>

    </p>
    <p style="font-size: 12px; color: #888; margin-top: 10px;">
        Headphones Recommended.<br>
        Microphone Access Required.
    </p>
    <button id="start-btn">START JAMMING</button>
</div>

<script>
/**
 * FOREST'S POCKET JAMROOM - V12 CORE LOGIC
 */

const AudioContext = window.AudioContext || window.webkitAudioContext;
let ctx;
let masterGain, compressor;
let analyser;
let micStream, micNode;

// Dual Bus System
let instBus, micBus; // Buses
let micGateGain;     // Input Gate for Mic
let micMonitorGain;  // Monitor Gate (Output to speakers)
let instFXReturn, micFXReturn; // FX Outputs

// FX Nodes
let reverbBuffer = null;
let instReverb, instDelay, instFeedback, instDelayGain;
let micReverb, micDelay, micFeedback, micDelayGain;

const STATE = { IDLE: 0, ARMED: 1, RECORDING_1: 2, PLAYING: 3, OVERDUB: 4, SAMPLING_ARMED: 5, SAMPLING_REC: 6 };
let currentState = STATE.IDLE;
let currentMode = 'drums';
let lastInstrumentMode = 'drums'; 
let isPowered = true;
let isMinorScale = false;

// EXPANDED SOUND LIBRARY (8 Styles Each)
const DRUM_STYLES = ['Standard', '808', 'Acoustic', 'Industrial', 'Toy', 'Lofi', 'Techno', 'Orchestral'];
const SYNTH_STYLES = ['Saw Lead', 'Deep Bass', 'Soft Sine', 'Retro Pad', 'Pluck', 'Chords', 'Acid', 'Dream'];
let currentDrumIdx = 0; let currentSynthIdx = 0;
const DRUM_PADS = ['kick', 'snare', 'hat', 'tom', 'clap', 'perc1', 'perc2', 'crash'];

// SCALES (Root C4)
const SCALE_MAJOR = [261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88, 523.25];
const SCALE_MINOR = [261.63, 293.66, 311.13, 349.23, 392.00, 415.30, 466.16, 523.25];

let loopBuffer = null; let loopSource = null; let recBuffer = [];    
let loopStartTime = 0; let loopLengthSamples = 0;
let inputThreshold = 0.005;
let undoStack = []; let undoTimeout; let hasReset = false;
let minLoopLength = 2000;
const LATENCY_COMPENSATION_SAMPLES = 5120; 

let userSamples = new Array(8).fill(null);
let heldPadIndex = -1;
let sampleRecBuffer = [];

let playbackRate = 1.0;
let recStartTime = 0;

// UI
const els = {
    knobSpeed: document.getElementById('knob-speed'),
    knobGlitch: document.getElementById('knob-glitch'), 
    recBtn: document.getElementById('btn-rec'),
    recLed: document.getElementById('rec-led'),
    undoBtn: document.getElementById('btn-undo'),
    micLed: document.getElementById('mic-led'),
    overlay: document.getElementById('overlay'),
    startBtn: document.getElementById('start-btn'),
    padsGrid: document.getElementById('pads-grid'),
    modes: document.querySelectorAll('.mode-btn'),
    status: document.getElementById('status-log'),
    device: document.getElementById('device'),
    powerSwitch: document.getElementById('power-switch'),
    scaleSwitch: document.getElementById('scale-switch')
};

function log(msg) {
    els.status.innerText = msg;
    setTimeout(() => { if(els.status.innerText === msg) els.status.innerText = ''; }, 2000);
}

// Mobile Pinch Prevent
document.addEventListener('gesturestart', function(e) { e.preventDefault(); });
document.addEventListener('gesturechange', function(e) { e.preventDefault(); });
document.addEventListener('gestureend', function(e) { e.preventDefault(); });
document.addEventListener('touchmove', function(e) { if(e.scale !== 1) e.preventDefault(); }, { passive: false });

els.startBtn.addEventListener('click', async () => {
    try {
        ctx = new AudioContext();
        await ctx.resume();
        
        compressor = ctx.createDynamicsCompressor();
        compressor.threshold.value = -12;
        compressor.ratio.value = 12;
        masterGain = ctx.createGain();
        masterGain.gain.value = 0.9;
        compressor.connect(masterGain);
        masterGain.connect(ctx.destination);

        setupDualFX();

        analyser = ctx.createAnalyser();
        analyser.fftSize = 256;

        try {
            micStream = await navigator.mediaDevices.getUserMedia({ audio: { 
                echoCancellation: false, noiseSuppression: false, autoGainControl: false, latency: 0 
            }});
            micNode = ctx.createMediaStreamSource(micStream);
            micNode.connect(analyser); 
            
            micGateGain = ctx.createGain();
            micGateGain.gain.value = 0; 
            micNode.connect(micGateGain);
            micGateGain.connect(micBus);
            
        } catch (e) { console.warn("Mic access denied."); }

        initUI(); initPads(); setupKeys();
        requestAnimationFrame(updateLoop);
        els.overlay.style.display = 'none';
        els.powerSwitch.classList.add('power-active'); 
        setupRecorder();
        
    } catch (e) { alert("Audio Init Failed: " + e); }
});

function setupDualFX() {
    reverbBuffer = createReverbBuffer();

    instBus = ctx.createGain(); instFXReturn = ctx.createGain(); instBus.connect(instFXReturn); 
    instReverb = ctx.createConvolver(); instReverb.buffer = reverbBuffer;
    let irGain = ctx.createGain(); irGain.gain.value = 0; instReverb.gainNode = irGain;
    instBus.connect(instReverb); instReverb.connect(irGain); irGain.connect(instFXReturn);
    instDelay = ctx.createDelay(1.0); instDelay.delayTime.value = 0.3;
    instFeedback = ctx.createGain(); instFeedback.gain.value = 0.3;
    instDelayGain = ctx.createGain(); instDelayGain.gain.value = 0;
    instBus.connect(instDelay); instDelay.connect(instFeedback); instFeedback.connect(instDelay);
    instDelay.connect(instDelayGain); instDelayGain.connect(instFXReturn);
    instFXReturn.connect(compressor);

    micBus = ctx.createGain(); micFXReturn = ctx.createGain(); micBus.connect(micFXReturn);
    micReverb = ctx.createConvolver(); micReverb.buffer = reverbBuffer;
    let mrGain = ctx.createGain(); mrGain.gain.value = 0; micReverb.gainNode = mrGain;
    micBus.connect(micReverb); micReverb.connect(mrGain); mrGain.connect(micFXReturn);
    micDelay = ctx.createDelay(1.0); micDelay.delayTime.value = 0.3;
    micFeedback = ctx.createGain(); micFeedback.gain.value = 0.3;
    micDelayGain = ctx.createGain(); micDelayGain.gain.value = 0;
    micBus.connect(micDelay); micDelay.connect(micFeedback); micFeedback.connect(micDelay);
    micDelay.connect(micDelayGain); micDelayGain.connect(micFXReturn);
    
    // FIX: Monitor Gain Node to control when we hear the mic
    micMonitorGain = ctx.createGain();
    micMonitorGain.gain.value = 1.0; 
    micFXReturn.connect(micMonitorGain);
    micMonitorGain.connect(compressor);
}

function createReverbBuffer() {
    const len = ctx.sampleRate * 2.0; 
    const buffer = ctx.createBuffer(2, len, ctx.sampleRate);
    for (let c = 0; c < 2; c++) {
        const data = buffer.getChannelData(c);
        for (let i = 0; i < len; i++) data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / len, 3);
    }
    return buffer;
}

// --- Sound Engine ---
function makeOsc(type, freq, start, dur, volNode, volEnv) {
    const osc = ctx.createOscillator();
    osc.type = type; osc.frequency.value = freq;
    osc.connect(volNode); osc.start(start); osc.stop(start + dur);
    return osc;
}

function playDrum(type) {
    const t = ctx.currentTime; const gain = ctx.createGain(); gain.connect(instBus);
    const style = DRUM_STYLES[currentDrumIdx];

    // Helper: Simple enveloped osc
    const hit = (freq, decay, type='sine', vol=1) => {
        const osc = ctx.createOscillator(); osc.type = type;
        osc.frequency.setValueAtTime(freq, t); osc.frequency.exponentialRampToValueAtTime(10, t + decay);
        gain.gain.setValueAtTime(vol, t); gain.gain.exponentialRampToValueAtTime(0.01, t + decay);
        osc.connect(gain); osc.start(t); osc.stop(t + decay);
    };

    if(type === 'kick') {
        if(style === '808') hit(60, 0.8, 'sine', 1);
        else if(style === 'Industrial') { hit(100, 0.3, 'square', 0.8); }
        else if(style === 'Techno') { hit(150, 0.15, 'sine', 1); makeNoise(0.05, 0.5, t); }
        else if(style === 'Orchestral') { hit(40, 1.2, 'sine', 1); makeNoise(0.5, 0.2, t); }
        else hit(150, 0.3);
    } 
    else if(type === 'snare') {
        if(style === '808') { hit(200, 0.1, 'triangle', 0.5); makeNoise(0.2, 0.4, t); }
        else if(style === 'Acoustic') { hit(250, 0.1, 'sine', 0.5); makeNoise(0.25, 0.6, t); }
        else if(style === 'Toy') { hit(800, 0.05, 'square', 0.5); }
        else { hit(250, 0.1, 'triangle', 0.5); makeNoise(0.15, 0.7, t); }
    }
    else if(type === 'hat') {
        let len = (style === '808' || style === 'Techno') ? 0.05 : 0.08;
        if(style === 'Lofi') len = 0.12;
        makeNoise(len, (style==='Lofi'?0.2:0.4), t, true);
    }
    else if(type === 'tom') {
        const freq = (style==='Toy') ? 400 : 150;
        hit(freq, 0.4, 'sine', 0.8);
    }
    else if(type === 'clap') {
        makeNoise(0.01, 0.6, t); makeNoise(0.01, 0.5, t+0.015); makeNoise(0.01, 0.4, t+0.03); makeNoise(0.1, 0.3, t+0.04);
    }
    else if(type === 'crash') {
        makeNoise(0.8, 0.6, t, true);
    }
    else { makeNoise(0.1, 0.5, t); } // Percs
}

function makeNoise(duration, vol, time, highpass = false) {
    const bufferSize = ctx.sampleRate * duration; const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = buffer.getChannelData(0); for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
    const noise = ctx.createBufferSource(); noise.buffer = buffer; const noiseGain = ctx.createGain();
    noiseGain.gain.setValueAtTime(vol, time); noiseGain.gain.exponentialRampToValueAtTime(0.01, time + duration);
    noise.connect(noiseGain); 
    
    if(highpass) { 
        const hp = ctx.createBiquadFilter(); hp.type = 'highpass'; hp.frequency.value = 5000; 
        noiseGain.connect(hp); hp.connect(instBus); 
    } 
    else { noiseGain.connect(instBus); } 
    noise.start(time);
}

function playSynth(rawFreq) {
    const t = ctx.currentTime;
    const style = SYNTH_STYLES[currentSynthIdx];
    const gain = ctx.createGain(); gain.connect(instBus);
    
    // Scale adjustment usually happens in note selection, but freq is passed here
    let f = rawFreq; 

    if(style === 'Saw Lead') {
        const osc = ctx.createOscillator(); osc.type = 'sawtooth'; osc.frequency.value = f;
        const filter = ctx.createBiquadFilter(); filter.type = 'lowpass';
        filter.frequency.setValueAtTime(200, t); filter.frequency.exponentialRampToValueAtTime(4000, t + 0.1);
        gain.gain.setValueAtTime(0, t); gain.gain.linearRampToValueAtTime(0.4, t+0.02); gain.gain.exponentialRampToValueAtTime(0.01, t+0.6);
        osc.connect(filter); filter.connect(gain); osc.start(t); osc.stop(t+0.6);
    }
    else if (style === 'Deep Bass') {
        // Sub oscillator
        const osc1 = ctx.createOscillator(); osc1.type = 'sine'; osc1.frequency.value = f / 2;
        const osc2 = ctx.createOscillator(); osc2.type = 'square'; osc2.frequency.value = f / 2;
        const filter = ctx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.value = 400;
        osc1.connect(gain); osc2.connect(filter); filter.connect(gain);
        gain.gain.setValueAtTime(0.8, t); gain.gain.exponentialRampToValueAtTime(0.01, t+0.6);
        osc1.start(t); osc1.stop(t+0.6); osc2.start(t); osc2.stop(t+0.6);
    }
    else if (style === 'Chords') {
        // Major/Minor triad based on scale logic is hard here without key info, so we stack fixed intervals
        // Stacking 5ths and Octaves for a "Power Chord" feel which works usually
        [f, f*1.5, f*2].forEach((fr, i) => {
            const osc = ctx.createOscillator(); osc.type = 'sawtooth'; osc.frequency.value = fr;
            osc.detune.value = Math.random()*10 - 5;
            const lg = ctx.createGain(); lg.gain.value = 0.2 / (i+1);
            osc.connect(lg); lg.connect(gain);
            osc.start(t); osc.stop(t+0.6);
        });
        gain.gain.setValueAtTime(0, t); gain.gain.linearRampToValueAtTime(1, t+0.05); gain.gain.exponentialRampToValueAtTime(0.01, t+0.6);
    }
    else if (style === 'Acid') {
        const osc = ctx.createOscillator(); osc.type = 'sawtooth'; osc.frequency.value = f;
        const filter = ctx.createBiquadFilter(); filter.type = 'lowpass'; filter.Q.value = 20;
        filter.frequency.setValueAtTime(300, t); filter.frequency.linearRampToValueAtTime(2000, t+0.2); filter.frequency.linearRampToValueAtTime(300, t+0.5);
        osc.connect(filter); filter.connect(gain);
        gain.gain.setValueAtTime(0.4, t); gain.gain.exponentialRampToValueAtTime(0.01, t+0.5);
        osc.start(t); osc.stop(t+0.5);
    }
    else if (style === 'Dream') {
        const osc = ctx.createOscillator(); osc.type = 'triangle'; osc.frequency.value = f;
        const osc2 = ctx.createOscillator(); osc2.type = 'triangle'; osc2.frequency.value = f; osc2.detune.value = 15;
        gain.gain.setValueAtTime(0, t); gain.gain.linearRampToValueAtTime(0.4, t+0.3); gain.gain.linearRampToValueAtTime(0, t+1.5);
        osc.connect(gain); osc2.connect(gain);
        osc.start(t); osc.stop(t+1.5); osc2.start(t); osc2.stop(t+1.5);
    }
    else {
        // Fallback/Standard
        const osc = ctx.createOscillator(); osc.type = (style==='Pluck')?'square':'triangle'; osc.frequency.value = f;
        const filter = ctx.createBiquadFilter(); filter.frequency.value = 2000;
        if(style==='Pluck') { filter.frequency.exponentialRampToValueAtTime(200, t+0.2); }
        gain.gain.setValueAtTime(0.5, t); gain.gain.exponentialRampToValueAtTime(0.01, t+0.4);
        osc.connect(filter); filter.connect(gain); osc.start(t); osc.stop(t+0.4);
    }
}

function playSample(index) {
    if(!userSamples[index]) return;
    const src = ctx.createBufferSource(); src.buffer = userSamples[index]; src.connect(instBus); src.start(0);
}

function isRecordingState() {
    return (currentState === STATE.RECORDING_1 || currentState === STATE.OVERDUB || currentState === STATE.ARMED || currentState === STATE.SAMPLING_ARMED || currentState === STATE.SAMPLING_REC);
}

// --- Recorder ---
const bufferSize = 4096;
let recorderNode;
let recordingStream = [];

function setupRecorder() {
    if(recorderNode) return;
    recorderNode = ctx.createScriptProcessor(bufferSize, 1, 1);
    recorderNode.onaudioprocess = (e) => {
        if (!isRecordingState()) return;
        const input = e.inputBuffer.getChannelData(0);
        
        if (currentState === STATE.SAMPLING_ARMED) {
            let sum = 0; for(let i=0; i<input.length; i++) sum += input[i]*input[i];
            if(Math.sqrt(sum/input.length) > inputThreshold) {
                currentState = STATE.SAMPLING_REC; sampleRecBuffer = [];
                if (heldPadIndex !== -1) {
                    const pad = els.padsGrid.children[heldPadIndex];
                    if(pad) { pad.classList.remove('recording-armed'); pad.classList.add('recording'); }
                }
                log("SAMPLING..."); updateMicGate(); 
            } else { return; }
        }

        if (currentState === STATE.SAMPLING_REC) { sampleRecBuffer.push(new Float32Array(input)); return; }

        if (currentState === STATE.ARMED) {
            let sum = 0; for(let i=0; i<input.length; i++) sum += input[i]*input[i];
            if(Math.sqrt(sum/input.length) > inputThreshold) startFirstRecording(); else return;
        }
        
        if (currentState === STATE.RECORDING_1 || currentState === STATE.OVERDUB) recordingStream.push(new Float32Array(input));
        
        const output = e.outputBuffer.getChannelData(0); for (let i = 0; i < output.length; i++) output[i] = 0; 
    };
    instFXReturn.connect(recorderNode); micFXReturn.connect(recorderNode);
    const zeroGain = ctx.createGain(); zeroGain.gain.value = 0; recorderNode.connect(zeroGain); zeroGain.connect(ctx.destination);
}

// --- Control Logic ---
function onRecPress() {
    if(!isPowered) return;
    if (currentMode === 'voice' && heldPadIndex !== -1) {
        currentState = STATE.SAMPLING_ARMED; sampleRecBuffer = [];
        const pad = els.padsGrid.children[heldPadIndex];
        if(pad) pad.classList.add('recording-armed');
        log("ARMED: SPEAK"); updateMicGate(); return;
    }
    if (currentState === STATE.IDLE) {
        currentState = STATE.ARMED; els.recLed.className = 'rec-led-ring standby'; recordingStream = []; 
        log("ARMED: MAKE SOUND"); updateMicGate();
    } else if (currentState === STATE.PLAYING) startOverdub();
}

function onRecRelease() {
    if (currentState === STATE.SAMPLING_REC || currentState === STATE.SAMPLING_ARMED) finishSampling();
    else if (currentState === STATE.RECORDING_1) finishFirstLoop();
    else if (currentState === STATE.ARMED) { currentState = STATE.IDLE; els.recLed.className = 'rec-led-ring'; log("CANCELLED"); updateMicGate(); }
    else if (currentState === STATE.OVERDUB) stopOverdub();
}

function finishSampling() {
    if (currentState === STATE.SAMPLING_REC && sampleRecBuffer.length > 0) {
        const totalSamples = sampleRecBuffer.length * bufferSize;
        const rawBuffer = ctx.createBuffer(1, totalSamples, ctx.sampleRate);
        const data = rawBuffer.getChannelData(0); let offset = 0;
        for(let chunk of sampleRecBuffer) { data.set(chunk, offset); offset += chunk.length; }
        const trim = LATENCY_COMPENSATION_SAMPLES; 
        if(totalSamples > trim) {
            const trimmedBuffer = ctx.createBuffer(1, totalSamples - trim, ctx.sampleRate);
            trimmedBuffer.copyToChannel(data.subarray(trim), 0);
            userSamples[heldPadIndex] = trimmedBuffer;
        } else { userSamples[heldPadIndex] = rawBuffer; }
        log("SAMPLE SAVED");
    } else { log("SAMPLE CANCELLED"); }
    const pad = els.padsGrid.children[heldPadIndex];
    if(pad) { pad.classList.remove('recording'); pad.classList.remove('recording-armed'); }
    currentState = (loopBuffer !== null) ? STATE.PLAYING : STATE.IDLE; updateMicGate(); updatePadVisuals();
}

function startFirstRecording() {
    currentState = STATE.RECORDING_1; els.recLed.className = 'rec-led-ring recording';
    recordingStream = []; recStartTime = ctx.currentTime; log("RECORDING..."); updateMicGate();
}

function finishFirstLoop() {
    const totalSamples = recordingStream.length * bufferSize;
    if(totalSamples < minLoopLength) { currentState = STATE.IDLE; els.recLed.className = 'rec-led-ring'; log("TOO SHORT"); updateMicGate(); return; }
    currentState = STATE.PLAYING; els.recLed.className = 'rec-led-ring playing'; undoStack.push('RESET');
    const rawBuffer = ctx.createBuffer(1, totalSamples, ctx.sampleRate); const data = rawBuffer.getChannelData(0); let offset = 0;
    for(let chunk of recordingStream) { data.set(chunk, offset); offset += chunk.length; }
    loopBuffer = rawBuffer; loopLengthSamples = totalSamples; startPlayback(); log("LOOPING"); updateMicGate();
}

function startOverdub() {
    if(!loopBuffer) return;
    saveUndoState(); currentState = STATE.OVERDUB; els.recLed.className = 'rec-led-ring recording';
    recordingStream = []; recStartTime = ctx.currentTime; log("DUBBING..."); updateMicGate();
}

function stopOverdub() {
    currentState = STATE.PLAYING; els.recLed.className = 'rec-led-ring playing'; log("PLAYING"); updateMicGate();
    if(!loopBuffer || recordingStream.length === 0) return;
    const oldData = loopBuffer.getChannelData(0); const loopTotalSamples = loopBuffer.length;
    
    // Stable calculation based on time elapsed
    let timeElapsed = ctx.currentTime - loopStartTime;
    let currentLoopPos = (timeElapsed * ctx.sampleRate * playbackRate) % loopTotalSamples;
    
    while(currentLoopPos < 0) currentLoopPos += loopTotalSamples;
    while(currentLoopPos >= loopTotalSamples) currentLoopPos -= loopTotalSamples;

    currentLoopPos -= (playbackRate * LATENCY_COMPENSATION_SAMPLES);
    while(currentLoopPos < 0) currentLoopPos += loopTotalSamples;
    while(currentLoopPos >= loopTotalSamples) currentLoopPos -= loopTotalSamples;

    const flatRecLen = recordingStream.length * bufferSize;
    const flatRec = new Float32Array(flatRecLen);
    let off = 0;
    for(let chunk of recordingStream) { flatRec.set(chunk, off); off += chunk.length; }
    
    for (let i = 0; i < flatRecLen; i++) {
        const inputSample = flatRec[flatRecLen - 1 - i];
        let targetIndex = currentLoopPos - (i * playbackRate);
        while(targetIndex < 0) targetIndex += loopTotalSamples;
        while(targetIndex >= loopTotalSamples) targetIndex -= loopTotalSamples;
        oldData[Math.floor(targetIndex)] += inputSample;
    }
}

function startPlayback() {
    if(loopSource) { try { loopSource.stop(); } catch(e){} }
    loopSource = ctx.createBufferSource(); loopSource.buffer = loopBuffer; loopSource.loop = true;
    loopSource.loopStart = 0; loopSource.loopEnd = loopBuffer.duration;
    loopSource.playbackRate.value = playbackRate;
    loopSource.connect(compressor);
    loopStartTime = ctx.currentTime;
    loopSource.start(0);
}

// --- UI Logic ---
function initPads() {
    els.padsGrid.innerHTML = '';
    for(let i=0; i<8; i++) {
        const btn = document.createElement('div'); btn.className = 'pad';
        btn.addEventListener('pointerdown', (e) => { 
            e.preventDefault(); if(!isPowered) return;
            btn.setPointerCapture(e.pointerId); heldPadIndex = i; btn.classList.add('active'); hitPad(i, btn); 
        });
        btn.addEventListener('pointerup', (e) => { heldPadIndex = -1; btn.classList.remove('active'); btn.releasePointerCapture(e.pointerId); });
        btn.addEventListener('pointercancel', (e) => { heldPadIndex = -1; btn.classList.remove('active'); btn.releasePointerCapture(e.pointerId); });
        els.padsGrid.appendChild(btn);
    }
}

function updatePadVisuals() {
    const pads = Array.from(els.padsGrid.children);
    pads.forEach((pad, i) => {
        pad.classList.remove('has-sample');
        if (currentMode === 'voice' && userSamples[i]) pad.classList.add('has-sample');
    });
    if(currentMode === 'voice') els.padsGrid.classList.add('mode-voice');
    else els.padsGrid.classList.remove('mode-voice');
}

function hitPad(index, el) {
    if (currentMode === 'voice') {
        if (userSamples[index]) playSample(index);
    } else {
        if (currentMode === 'drums') playDrum(DRUM_PADS[index]);
        else if (currentMode === 'synth') {
            const freqs = isMinorScale ? SCALE_MINOR : SCALE_MAJOR;
            playSynth(freqs[index]);
        }
    }
}

function updateMicGate() {
    if(!micGateGain || !micMonitorGain) return;
    
    const isVoiceMode = (currentMode === 'voice');
    const isSampling = (currentState === STATE.SAMPLING_ARMED || currentState === STATE.SAMPLING_REC);
    const isLoopRecording = (currentState === STATE.RECORDING_1 || currentState === STATE.OVERDUB);
    const isRecording = isSampling || isLoopRecording || currentState === STATE.ARMED;

    // 1. INPUT GATE: Open whenever we need to capture audio (Sampling or Looping)
    if(isRecording) {
        micGateGain.gain.setTargetAtTime(1.0, ctx.currentTime, 0.05); 
    } else {
        micGateGain.gain.setTargetAtTime(0.0, ctx.currentTime, 0.05); 
    }

    // 2. MONITOR GATE: Always mute real-time monitoring to prevent feedback.
    // We only want to hear the audio AFTER it has been recorded/looped.
    micMonitorGain.gain.setTargetAtTime(0.0, ctx.currentTime, 0.05);
}

function switchMode(newMode) {
    if(!isPowered) return;
    const btn = Array.from(els.modes).find(b => b.dataset.mode === newMode);
    
    // Cycle sounds if clicking active mode
    if(btn.classList.contains('active')) {
        if(newMode === 'drums') { currentDrumIdx = (currentDrumIdx + 1) % DRUM_STYLES.length; log("DRUMS: " + DRUM_STYLES[currentDrumIdx]); } 
        else if(newMode === 'synth') { currentSynthIdx = (currentSynthIdx + 1) % SYNTH_STYLES.length; log("SYNTH: " + SYNTH_STYLES[currentSynthIdx]); }
        btn.classList.add('flash-trigger'); setTimeout(()=>btn.classList.remove('flash-trigger'), 200); return;
    }

    els.modes.forEach(b => b.classList.remove('active')); btn.classList.add('active');
    if(currentMode !== 'voice') lastInstrumentMode = currentMode;
    currentMode = newMode; log("MODE: " + currentMode.toUpperCase());
    updatePadVisuals(); updateMicGate();
}

function initUI() {
    els.modes.forEach(btn => {
        btn.addEventListener('click', () => switchMode(btn.dataset.mode));
    });

    els.scaleSwitch.addEventListener('click', () => {
        if(!isPowered) return;
        isMinorScale = !isMinorScale;
        els.scaleSwitch.classList.toggle('minor', isMinorScale);
        log("SCALE: " + (isMinorScale ? "MINOR" : "MAJOR"));
    });

    els.recBtn.addEventListener('pointerdown', (e) => { if(!isPowered) return; e.preventDefault(); els.recBtn.setPointerCapture(e.pointerId); onRecPress(); });
    els.recBtn.addEventListener('pointerup', (e) => { e.preventDefault(); onRecRelease(); els.recBtn.releasePointerCapture(e.pointerId); });
    els.recBtn.addEventListener('pointercancel', (e) => { onRecRelease(); els.recBtn.releasePointerCapture(e.pointerId); });
    els.powerSwitch.addEventListener('click', togglePower);

    setupKnob(els.knobSpeed, (val) => {
        if(!isPowered) return;
        if (val > 0.45 && val < 0.55) { playbackRate = 1.0; }
        else if (val >= 0.55) { if (val < 0.9) { playbackRate = 1.0 + ((val-0.55)/0.35)*1.5; } else { playbackRate = -2.0; } } 
        else if (val <= 0.45) { playbackRate = 1.0 - ((0.45 - val) / 0.225); }
        if (Math.abs(playbackRate) < 0.001) playbackRate = 0.001;
        if(loopSource) { loopSource.playbackRate.value = playbackRate; }
    }, true); 

    setupKnob(els.knobGlitch, (val) => {
        if(!isPowered || !instReverb) return;
        let rGain, dGain, dFeed;
        if (val > 0.45 && val < 0.55) { rGain=0; dGain=0; dFeed=0; }
        else if (val >= 0.55) { rGain=0; const norm = (val-0.55)/0.45; dGain=norm*0.8; dFeed=0.2+(norm*0.5); } 
        else if (val <= 0.45) { dGain=0; dFeed=0; const norm = (0.45-val)/0.45; rGain=norm*1.5; }
        instReverb.gainNode.gain.value = rGain; micReverb.gainNode.gain.value = rGain;
        instDelayGain.gain.value = dGain; micDelayGain.gain.value = dGain;
        instFeedback.gain.value = dFeed; micFeedback.gain.value = dFeed;
    }, true);
}

function togglePower() {
    isPowered = !isPowered;
    if(isPowered) { els.powerSwitch.classList.add('power-active'); els.device.classList.remove('powered-off'); ctx.resume(); log("RESUME"); } 
    else { els.powerSwitch.classList.remove('power-active'); els.device.classList.add('powered-off'); ctx.suspend(); }
}

function setupKnob(el, callback, magnet = false) {
    let startY = 0; let currentDeg = 0;
    const update = (y) => {
        const delta = startY - y; currentDeg += delta * 2; currentDeg = Math.min(135, Math.max(-135, currentDeg));
        let visualDeg = currentDeg; if (magnet && Math.abs(currentDeg) < 15) visualDeg = 0;
        el.style.transform = `rotate(${visualDeg}deg)`; callback((visualDeg + 135) / 270); startY = y;
    };
    el.addEventListener('pointerdown', e => { if(!isPowered) return; startY = e.clientY; el.setPointerCapture(e.pointerId);
        const move = e => update(e.clientY);
        const up = () => { el.removeEventListener('pointermove', move); el.removeEventListener('pointerup', up); el.releasePointerCapture(e.pointerId); };
        el.addEventListener('pointermove', move); el.addEventListener('pointerup', up);
    });
}

function updateLoop() {
    if(isPowered) {
        if (analyser) {
            const data = new Uint8Array(analyser.frequencyBinCount); analyser.getByteFrequencyData(data);
            let sum = 0; for(let v of data) sum += v;
            if ((sum/data.length) > 10) els.micLed.classList.add('active'); else els.micLed.classList.remove('active');
        }
    } else { els.micLed.classList.remove('active'); }
    requestAnimationFrame(updateLoop);
}

// Shortcuts
function setupKeys() {
    const padKeys = { 'q':0, 'w':1, 'e':2, 'r':3, 'a':4, 's':5, 'd':6, 'f':7 };
    let recKeyDown = false;
    let undoKeyDown = false;

    window.addEventListener('keydown', (e) => {
        if(!isPowered) return;
        if(e.repeat) return;
        
        // Mode Switches
        if(e.key === '1') switchMode('synth');
        if(e.key === '2') switchMode('voice');
        if(e.key === '3') switchMode('drums');

        // Undo (Ctrl) - Trigger on Press
        if(e.key === 'Control') {
            if(!undoKeyDown) {
                undoKeyDown = true;
                els.undoBtn.classList.add('active-key');
                // Simulate hold for clear logic
                startUndoTimer({ pointerId: -1 }); // Dummy ID for key
            }
        }

        const k = e.key.toLowerCase();
        if(k in padKeys) {
            const idx = padKeys[k]; heldPadIndex = idx;
            const btn = els.padsGrid.children[idx];
            if(btn) { btn.classList.add('active'); hitPad(idx, btn); }
        }
        if(e.key === 'Shift') { if(!recKeyDown) { recKeyDown = true; els.recBtn.classList.add('active-key'); onRecPress(); } }
        if(e.key === ' ') { e.preventDefault(); togglePower(); }
    });
    
    window.addEventListener('keyup', (e) => {
        if(!isPowered) return;
        
        if(e.key === 'Control') {
            undoKeyDown = false;
            els.undoBtn.classList.remove('active-key');
            endUndoTimer({ pointerId: -1 });
        }

        const k = e.key.toLowerCase();
        if(k in padKeys) {
            const idx = padKeys[k]; heldPadIndex = -1;
            const btn = els.padsGrid.children[idx]; if(btn) btn.classList.remove('active');
        }
        if(e.key === 'Shift') { recKeyDown = false; els.recBtn.classList.remove('active-key'); onRecRelease(); }
    });
}

// Undo
els.undoBtn.addEventListener('pointerdown', startUndoTimer);
els.undoBtn.addEventListener('pointerup', endUndoTimer);
els.undoBtn.addEventListener('pointercancel', endUndoTimer);

function startUndoTimer(e) { 
    if(!isPowered) return; 
    if(e.pointerId >= 0) els.undoBtn.setPointerCapture(e.pointerId); 
    hasReset = false; 
    undoTimeout = setTimeout(resetDevice, 1000); 
}

function endUndoTimer(e) { 
    clearTimeout(undoTimeout); 
    if(e.pointerId >= 0) els.undoBtn.releasePointerCapture(e.pointerId);
    if (!hasReset && isPowered) performUndo(); 
}

function saveUndoState() { if(!loopBuffer) return; const copy = new Float32Array(loopBuffer.getChannelData(0)); undoStack.push(copy); if(undoStack.length > 5) undoStack.shift(); }

function performUndo() {
    // Delete Sample
    if(currentMode === 'voice' && heldPadIndex !== -1) {
        if(userSamples[heldPadIndex]) { userSamples[heldPadIndex] = null; updatePadVisuals(); log("SAMPLE DELETED"); return; }
    }
    // Undo Loop
    if(undoStack.length > 0 && loopBuffer) {
        const prev = undoStack.pop();
        if(prev === 'RESET') resetDevice();
        else { loopBuffer.copyToChannel(prev, 0); log("UNDO LAYER"); els.undoBtn.style.color = '#000'; setTimeout(()=>els.undoBtn.style.color = '#fff', 200); }
    } else log("EMPTY");
}

function resetDevice() {
    hasReset = true; if(loopSource) loopSource.stop();
    loopBuffer = null; loopSource = null; recordingStream = []; undoStack = [];
    currentState = STATE.IDLE; els.recLed.className = 'rec-led-ring';
    els.undoBtn.classList.add('reset-flash'); setTimeout(() => els.undoBtn.classList.remove('reset-flash'), 500);
    log("RESET LOOP");
}
</script>
</body>
</html>