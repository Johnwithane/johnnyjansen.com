<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wishbone Interactive Catalog Creator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            margin: 0;
            overflow-x: hidden;
        }

        /* 3D Canvas Layers */
        /* Main Canvas (Background Items) */
        #c {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 40; 
            pointer-events: none; 
            display: block;
            background: transparent;
        }
        /* Modal Canvas (Popup Items) */
        #c-modal {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 110; 
            pointer-events: none; 
            display: block;
            background: transparent;
        }

        /* Modal Overlay */
        #editor-modal {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.6);
            z-index: 100;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(4px);
        }
        #editor-modal.active { display: flex; }

        /* Paper Sheet */
        .page-sheet {
            background: white;
            width: 210mm;
            min-height: 297mm;
            margin: 40px auto;
            padding: 15mm;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            position: relative; 
        }

        /* Interaction Target */
        .scene-element {
            width: 100%;
            aspect-ratio: 1 / 1;
            position: relative;
            cursor: grab;
            touch-action: none;
            z-index: 20; 
        }
        .scene-element:active { cursor: grabbing; }

        /* Print Image (Hidden by default) */
        .print-image {
            display: none;
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        /* Hover Controls */
        .item-controls {
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none; 
            z-index: 50; /* Higher than Canvas (40) */
        }
        .group:hover .item-controls {
            opacity: 1;
        }
        .control-btn {
            pointer-events: auto;
            background: white;
            color: #4B5563;
            border-radius: 9999px;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: all 0.2s;
        }
        .control-btn:hover {
            background: #2563EB;
            color: white;
            transform: scale(1.1);
        }
        .control-btn.btn-delete:hover {
            background: #EF4444;
            color: white;
        }

        /* --- PRINT STYLING --- */
        @media print {
            body { background: white; }
            .no-print { display: none !important; }
            #c, #c-modal { display: none !important; }
            
            .page-sheet {
                margin: 0; width: 100%; box-shadow: none;
                padding: 10mm; break-after: always;
            }
            
            .print-image { display: block !important; }
            .scene-element { display: none; }
            .page-break-avoid { break-inside: avoid; }
            .add-card { display: none !important; }
            .item-controls { display: none !important; }
        }

        input[type=range] { width: 100%; accent-color: #4B5563; }
        select {
            appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 0.5rem center;
            background-size: 1em;
        }
    </style>
</head>
<body>

    <canvas id="c"></canvas>
    <canvas id="c-modal"></canvas>

    <div class="no-print fixed top-4 right-4 z-50 flex gap-2 flex-col items-end">
        <div class="flex gap-2">
            <button onclick="prepareAndPrint()" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition flex items-center gap-2">
                <i class="fas fa-print"></i> Print PDF
            </button>
        </div>
        <button onclick="downloadHTML()" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg shadow-lg transition flex items-center gap-2 text-sm">
            <i class="fas fa-download"></i> Save & Download HTML
        </button>
    </div>

    <div id="content-anchor"></div>

    <div id="editor-modal" class="no-print">
        <div class="bg-white rounded-xl shadow-2xl w-[900px] max-w-[95vw] h-[80vh] flex overflow-hidden">
            
            <div class="w-1/2 bg-gray-100 relative flex flex-col justify-center items-center border-r border-gray-200">
                <div class="absolute top-4 left-4 text-xs font-bold text-gray-400 uppercase tracking-widest">Live Preview</div>
                <div id="modal-scene-target" class="w-full aspect-square relative z-50 cursor-grab active:cursor-grabbing"></div>
                <p class="text-xs text-gray-400 mt-4">Click & Drag to Rotate</p>
            </div>

            <div class="w-1/2 p-8 overflow-y-auto flex flex-col">
                <div class="flex justify-between items-center mb-6">
                    <h2 class="text-2xl font-bold text-gray-800">Edit Material</h2>
                    <button onclick="cancelEdit()" class="text-gray-400 hover:text-gray-600 transition">
                        <i class="fas fa-times fa-2x"></i>
                    </button>
                </div>

                <div id="modal-controls" class="space-y-6 flex-1">
                    </div>

                <div class="border-t pt-6 mt-6 flex justify-between items-center">
                    <button onclick="deleteCurrentItem()" class="text-red-500 hover:text-red-700 text-sm font-bold flex items-center gap-2">
                        <i class="fas fa-trash"></i> Delete
                    </button>
                    <div class="flex gap-2">                               
                        <button id="btn-copy-preset" onclick="copyAsPreset()" class="text-xs text-blue-600 hover:text-blue-800 font-bold underline decoration-dotted">
                            <i class="fas fa-code"></i> Copy
                        </button>
                        <button onclick="cancelEdit()" class="bg-gray-100 hover:bg-gray-200 text-gray-700 font-bold py-2 px-6 rounded transition">
                            Cancel
                        </button>
                        <button onclick="closeModal()" class="bg-gray-800 hover:bg-gray-900 text-white font-bold py-2 px-6 rounded transition">
                            Save
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // =========================================================================
        // ============================ DATA STATE =================================
        // =========================================================================

        const currentYear = new Date().getFullYear(); // <--- Get current year

        const COMPANY_INFO = {
            title: "Wishbone Site Furnishings",
            subtitle: `${currentYear} COLOUR & MATERIAL GUIDE`, // <--- Use variable
            contact: "WishboneLtd.com | (866) 626-0476",
            logoUrl: "https://wishboneltd.com/templates/yootheme/cache/c6/Wishbone-30-longer-c62913c2.webp"
        };

        const TEXTURE_REGISTRY = {
            'none': { type: 'none' },

            // --- WOODS & BAMBOO ---
            'bamboo_dark':          { type: 'url', url: 'textures/bamboo-dark.jpg' },
            'bamboo_light':         { type: 'url', url: 'textures/bamboo-light.jpg' },
            'wood_accoya':          { type: 'url', url: 'textures/wood-accoya.jpg' },
            'wood_redcedar':        { type: 'url', url: 'textures/wood-redCedar.jpg' },

            // --- PLASTICS ---
            'plastic_black':    { type: 'url', url: 'textures/Plastic-black.jpg' },
            'plastic_grey':     { type: 'url', url: 'textures/plastic-grey.jpg' },
            'plastic_redwood':  { type: 'url', url: 'textures/plastic-redwood.jpg' },
            'plastic_sand':     { type: 'url', url: 'textures/plastic-sand.jpg' },
            'plastic_walnut':   { type: 'url', url: 'textures/plastic-walnut.jpg' },

            // --- METALS ---
            'metal_blueash':       { type: 'url', url: 'textures/metal-blueAsh.jpg' },
            'metal_carbonblack':   { type: 'url', url: 'textures/metal-carbonBlack.jpg' },
            'metal_gun':           { type: 'url', url: 'textures/metal-gun.jpg' },
            'metal_nightblue':     { type: 'url', url: 'textures/metal-nightBlue.jpg' },
            'metal_oilbronze':     { type: 'url', url: 'textures/metal-oilBronze.jpg' },
            'metal_pewter':        { type: 'url', url: 'textures/metal-pewter.jpg' },
            'metal_rideaubrown':   { type: 'url', url: 'textures/metal-rideauBrown.jpg' },
            'metal_silver':        { type: 'url', url: 'textures/metal-silver.jpg' },
            'metal_texturedblack': { type: 'url', url: 'textures/metal-texturedBlack.jpg' },
            'metal_texturedwhite': { type: 'url', url: 'textures/metal-texturedWhite.jpg' },
            'metal_victorridge':   { type: 'url', url: 'textures/metal-VictorRidge.jpg' }
        };

        const TEXTURE_STYLES = {
            'none':      { label: 'Smooth / None', mapId: 'none', bumpId: 'none' },
            'accoya':    { label: 'Accoya Natural',      mapId: 'none',     bumpId: 'wood_accoya' },
            'cedar':     { label: 'Western Red Cedar',   mapId: 'none',   bumpId: 'wood_redcedar' },
            'bam_dk':    { label: 'Bamboo Dark',         mapId: 'none',     bumpId: 'bamboo_dark' },
            'bam_lt':    { label: 'Bamboo Light',        mapId: 'none',     bumpId: 'bamboo_light' },
            'p_black':   { label: 'Plastic Black',   mapId: 'plastic_black',   bumpId: 'plastic_black' },
            'p_grey':    { label: 'Plastic Grey',    mapId: 'plastic_grey',    bumpId: 'plastic_grey' },
            'p_redwood': { label: 'Plastic Redwood', mapId: 'plastic_redwood', bumpId: 'plastic_redwood' },
            'p_sand':    { label: 'Plastic Sand',    mapId: 'plastic_sand',    bumpId: 'plastic_sand' },
            'p_walnut':  { label: 'Plastic Walnut',  mapId: 'plastic_walnut',  bumpId: 'plastic_walnut' },
            'm_blue':    { label: 'Blue Ash',        mapId: 'metal_blueash',       bumpId: 'metal_blueash' },
            'm_carbon':  { label: 'Carbon Black',    mapId: 'metal_carbonblack',   bumpId: 'metal_carbonblack' },
            'm_gun':     { label: 'Gun Metal',       mapId: 'metal_gun',           bumpId: 'metal_gun' },
            'm_night':   { label: 'Night Blue',      mapId: 'metal_nightblue',     bumpId: 'metal_nightblue' },
            'm_oil':     { label: 'Oil Bronze',      mapId: 'metal_oilbronze',     bumpId: 'metal_oilbronze' },
            'm_pewter':  { label: 'Pewter',          mapId: 'metal_pewter',        bumpId: 'metal_pewter' },
            'm_rideau':  { label: 'Rideau Brown',    mapId: 'metal_rideaubrown',   bumpId: 'metal_rideaubrown' },
            'm_silver':  { label: 'Silver',          mapId: 'metal_silver',        bumpId: 'metal_silver' },
            'm_tex_bk':  { label: 'Textured Black',  mapId: 'metal_texturedblack', bumpId: 'metal_texturedblack' },
            'm_tex_wh':  { label: 'Textured White',  mapId: 'metal_texturedwhite', bumpId: 'metal_texturedwhite' },
            'm_victor':  { label: 'Victor Ridge',    mapId: 'metal_victorridge',   bumpId: 'metal_victorridge' },
        };

        const MATERIAL_PRESETS = {
            'matte_plastic': { label: 'Matte Plastic', roughness: 0.9, metalness: 0.0, bumpScale: 0.0, style: 'none' },
            'gloss_plastic': { label: 'Gloss Plastic', roughness: 0.1, metalness: 0.0, bumpScale: 0.0, style: 'none' },
            'satin_metal':   { label: 'Satin Metal',   roughness: 0.4, metalness: 0.5, bumpScale: 0.0, style: 'none' },
            'rough_metal':   { label: 'Rough/Cast Metal', roughness: 0.7, metalness: 0.5, bumpScale: 0.05, style: 'm_tex_bk' },
            'wood_natural':  { label: 'Natural Wood', roughness: 0.8, metalness: 0.0, bumpScale: 0.05, style: 'accoya' },
            'concrete':      { label: 'Concrete',     roughness: 0.95, metalness: 0.0, bumpScale: 0.15, style: 'none' },
            'recycled':      { label: 'Recycled Plastic', roughness: 0.9, metalness: 0.0, bumpScale: 0.05, style: 'p_grey' }
        };

// -- DATA_START --
        let CATEGORIES = [
            {
                id: 1,
                title: "Lumber Options",
                description: "Natural and modified wood selections.",
                items: [
                    { id: 101, name: "Accoya Natural",  color: "#f2dcb3", shape: "plank", roughness: 0.8, metalness: 0, renderMode: 'texture', mapId: 'wood_accoya',   bumpId: 'wood_accoya',   bumpScale: 0.005, textureScale: 1.0, brightness: 1.0, contrast: 1.0 },
                    { id: 102, name: "Western Red Cedar", color: "#d99058", shape: "plank", roughness: 0.8, metalness: 0, renderMode: 'texture', mapId: 'wood_redcedar', bumpId: 'wood_redcedar', bumpScale: 0.005, textureScale: 1.0, brightness: 1.0, contrast: 1.0 },
                    { id: 103, name: "Bamboo Light",      color: "#e6c288", shape: "plank", roughness: 0.7, metalness: 0, renderMode: 'texture', mapId: 'bamboo_light',  bumpId: 'bamboo_light',  bumpScale: 0.005, textureScale: 1.0, brightness: 1.0, contrast: 1.0 },
                    { id: 104, name: "Bamboo Dark",      color: "#e6c288", shape: "plank", roughness: 0.7, metalness: 0, renderMode: 'texture', mapId: 'bamboo_dark',  bumpId: 'bamboo_dark',  bumpScale: 0.005, textureScale: 1.0, brightness: 1.0, contrast: 1.0 },

                ]
            },
            {
                id: 2,
                title: "Recycled Plastic",
                description: "Durable, sustainable recycled plastic lumber.",
                items: [
                    { id: 201, name: "Weathered Redwood", color: "#8a5e4e", shape: "plank", roughness: 0.8, metalness: 0, renderMode: 'texture', mapId: 'plastic_redwood', bumpId: 'plastic_redwood', bumpScale: 0.005, textureScale: 0.5, brightness: 1.0, contrast: 1.0 },
                    { id: 202, name: "Slate Grey",        color: "#707070", shape: "plank", roughness: 0.8, metalness: 0, renderMode: 'texture', mapId: 'plastic_grey',    bumpId: 'plastic_grey',    bumpScale: 0.005, textureScale: 0.5, brightness: 1.0, contrast: 1.0 },
                    { id: 203, name: "Sand",              color: "#d6c096", shape: "plank", roughness: 0.8, metalness: 0, renderMode: 'texture', mapId: 'plastic_sand',    bumpId: 'plastic_sand',    bumpScale: 0.005, textureScale: 0.5, brightness: 1.0, contrast: 1.0 },
                ]
            },
            {
                id: 3,
                title: "Metals & Finishes",
                description: "Standard and textured metal powder coats.",
                items: [
                    { id: 301, name: "Silver",            color: "#c0c0c0", shape: "cube", roughness: 0.4, metalness: 0.8, renderMode: 'color', mapId: 'metal_silver',        bumpId: 'metal_silver',        bumpScale: 0.002, textureScale: 1.0, brightness: 1.0, contrast: 1.0 },
                    { id: 302, name: "Textured Black",    color: "#202020", shape: "cube", roughness: 0.6, metalness: 0.5, renderMode: 'texture', mapId: 'metal_texturedblack', bumpId: 'metal_texturedblack', bumpScale: 0.005, textureScale: 1.0, brightness: 1.0, contrast: 1.0 },
                    { id: 303, name: "Wishbone Red",        color: "#991b1b", shape: "cube", roughness: 0.4, metalness: 0.6, renderMode: 'color',   mapId: 'metal_texturedwhite',     bumpId: 'metal_texturedwhite',     bumpScale: 0.003, textureScale: 1.0, brightness: 1.0, contrast: 1.0 },
                ]
            }
        ];
        // -- DATA_END --

        const SHAPE_TYPES = ['sphere', 'cube', 'plank', 'cylinder'];
        const SHAPE_DEFAULTS = {
            cube:     { rotation: { x: -0.2, y: 0.4, z: 0 } },
            sphere:   { rotation: { x: 0, y: 0, z: 0 } },
            plank:    { rotation: { x: -0.2, y: 0.4, z: 0 } },
            cylinder: { rotation: { x: 0.2, y: 0.2, z: 0.0 } }
        };

        const textureLoader = new THREE.TextureLoader();
        // OPTIMIZATION: Cache textures to prevent reloading same URL multiple times
        const textureCache = {};

        // OPTIMIZATION: Reuse geometries
        let SHARED_GEOMETRIES = {}; 

        // =========================================================================
        // ======================== TEXTURE LOADER LOGIC ===========================
        // =========================================================================

        function getTextureFromId(regId, colorHex, scale = 1, isBump = false) {
            if (!regId || regId === 'none') return null;
            const regItem = TEXTURE_REGISTRY[regId];
            if (!regItem) return null;

            let targetUrl = regItem.url;
            if (isBump) targetUrl = targetUrl.replace(/(\.[\w\d_-]+)$/i, '_BUMP$1');
            
            // Create a unique key for the cache based on URL
            const cacheKey = targetUrl;
            
            let tex;
            if (textureCache[cacheKey]) {
                tex = textureCache[cacheKey].clone(); // Clone so we can change repeat per instance
                tex.needsUpdate = true;
            } else {
                if (regItem.type === 'url') {
                    tex = textureLoader.load(targetUrl);
                    if (!isBump) tex.encoding = THREE.sRGBEncoding;
                    textureCache[cacheKey] = tex; // Save original to cache
                }
            }
            
            if (tex) {
                tex.wrapS = THREE.RepeatWrapping;
                tex.wrapT = THREE.RepeatWrapping;
                tex.repeat.set(scale, scale); 
            }
            return tex;
        }

        // =========================================================================
        // ============================ 3D ENGINE ==================================
        // =========================================================================

        let canvas, renderer;
        let modalCanvas, modalRenderer;
        let scenes = []; 
        let modalSceneData = null;
        let isAnimating = true;

        function initThree() {
            // Main Canvas
            canvas = document.getElementById('c');
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas, 
                alpha: true, 
                antialias: true, 
                preserveDrawingBuffer: true 
            });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.autoClear = false;
            renderer.setClearColor( 0x000000, 0 );

            // Modal Canvas
            modalCanvas = document.getElementById('c-modal');
            modalRenderer = new THREE.WebGLRenderer({ 
                canvas: modalCanvas, 
                alpha: true, 
                antialias: true, 
                preserveDrawingBuffer: true 
            });
            modalRenderer.setPixelRatio(window.devicePixelRatio);
            modalRenderer.toneMapping = THREE.ACESFilmicToneMapping;
            modalRenderer.outputEncoding = THREE.sRGBEncoding;
            modalRenderer.autoClear = false;
            modalRenderer.setClearColor( 0x000000, 0 );

            // Initialize Shared Geometries (Optimization)
            SHARED_GEOMETRIES = {
                cube: new THREE.BoxGeometry(1, 1, 1),
                plank: new THREE.BoxGeometry(1.2, 1.2, 0.5),
                cylinder: new THREE.CylinderGeometry(0.5, 0.5, 1.1, 32),
                sphere: new THREE.SphereGeometry(0.7, 64, 64)
            };
        }

        // --- SCENE CREATION LOGIC ---
        function createSceneForItem(element, item, isModal = false) {
            const scene = new THREE.Scene();
            
            const camera = new THREE.PerspectiveCamera(30, 1, 0.1, 100);
            camera.position.z = 2.8; 
            camera.position.y = 1.5;
            camera.lookAt(0, 0, 0);

            // Lighting
            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambient);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
            dirLight.position.set(3, 2, 8);
            scene.add(dirLight);
            const rimLight = new THREE.DirectionalLight(0xffffff, 0.3);
            rimLight.position.set(-8, 2, -5);
            scene.add(rimLight);

            // Geometry (Used Shared)
            const shape = item.shape || 'sphere';
            const geometry = SHARED_GEOMETRIES[shape] || SHARED_GEOMETRIES['sphere'];
            
            const scale = item.textureScale || 1.0; 
            const isTextureMode = (item.renderMode === 'texture');

            // Map: Only load if Texture Mode is active
            const map = isTextureMode ? getTextureFromId(item.mapId, item.color, scale, false) : null;
            
            // Bump: ALWAYS load if present (allows painted wood grain etc)
            const bumpMap = getTextureFromId(item.bumpId, item.color, scale, true);

            // Defaults if not set in data
            const brightness = item.brightness !== undefined ? parseFloat(item.brightness) : 1.0;
            const contrast = item.contrast !== undefined ? parseFloat(item.contrast) : 1.0;

            const material = new THREE.MeshPhysicalMaterial({
                color: isTextureMode ? 0xffffff : item.color, 
                map: map,
                bumpMap: bumpMap,
                bumpScale: item.bumpScale || 0.0,
                roughness: item.roughness !== undefined ? parseFloat(item.roughness) : 0.5,
                metalness: item.metalness !== undefined ? parseFloat(item.metalness) : 0.0,
                clearcoat: 0.1,
                clearcoatRoughness: 0.1
            });

            // --- SHADER INJECTION FOR CONTRAST & BRIGHTNESS ---
            material.onBeforeCompile = function(shader) {
                shader.uniforms.uBrightness = { value: brightness - 1.0 }; 
                shader.uniforms.uContrast = { value: contrast };

                shader.fragmentShader = `
                    uniform float uBrightness;
                    uniform float uContrast;
                ` + shader.fragmentShader;

                shader.fragmentShader = shader.fragmentShader.replace(
                    '#include <map_fragment>',
                    `
                    #include <map_fragment>
                    #ifdef USE_MAP
                        vec3 color = diffuseColor.rgb;
                        color = (color - 0.5) * uContrast + 0.5; 
                        color = color + uBrightness;
                        diffuseColor.rgb = clamp(color, 0.0, 1.0);
                    #endif
                    `
                );
            };
            
            const mesh = new THREE.Mesh(geometry, material);
            const shapeDef = SHAPE_DEFAULTS[shape];
            if (shapeDef) {
                mesh.rotation.set(shapeDef.rotation.x, shapeDef.rotation.y, shapeDef.rotation.z);
            }

            scene.add(mesh);

            const sceneData = {
                scene, camera, element, mesh, shape,
                isDragging: false,
                lastMouse: { x: 0, y: 0 }
            };

            // Drag Interaction
            element.addEventListener('mousedown', (e) => {
                sceneData.isDragging = true;
                sceneData.lastMouse.x = e.clientX;
                sceneData.lastMouse.y = e.clientY;
            });

            if(isModal) {
                camera.position.z = 4.0; 
                camera.position.y = 2;
            }

            return sceneData;
        }

        // --- RENDER LOOP ---
        function render() {
            if (!isAnimating) return;

            // --- 1. RENDER MAIN CANVAS ---
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            if (canvas.width !== width || canvas.height !== height) {
                renderer.setSize(width, height, false);
            }

            renderer.setScissorTest(false);
            renderer.clear();
            renderer.setScissorTest(true);

            scenes.forEach((item) => {
                const rect = item.element.getBoundingClientRect();
                
                // Optimization: Simple culling
                if (rect.width === 0 || rect.height === 0) return;
                if ( rect.bottom < 0 || rect.top > window.innerHeight || 
                     rect.right < 0 || rect.left > window.innerWidth ) return;

                const left = rect.left;
                const bottom = window.innerHeight - rect.bottom;
                const w = rect.right - rect.left;
                const h = rect.bottom - rect.top;

                renderer.setViewport(left, bottom, w, h);
                renderer.setScissor(left, bottom, w, h);
                renderer.render(item.scene, item.camera);
            });
            renderer.setScissorTest(false);

            // --- 2. RENDER MODAL CANVAS (IF ACTIVE) ---
            if (modalSceneData) {
                const mWidth = modalCanvas.clientWidth;
                const mHeight = modalCanvas.clientHeight;
                if (modalCanvas.width !== mWidth || modalCanvas.height !== mHeight) {
                    modalRenderer.setSize(mWidth, mHeight, false);
                }

                modalRenderer.setScissorTest(false);
                modalRenderer.clear();
                modalRenderer.setScissorTest(true);

                const item = modalSceneData;
                const rect = item.element.getBoundingClientRect();
                if (rect.width > 0 && rect.height > 0) {
                      const left = rect.left;
                      const bottom = window.innerHeight - rect.bottom;
                      const w = rect.right - rect.left;
                      const h = rect.bottom - rect.top;

                      modalRenderer.setViewport(left, bottom, w, h);
                      modalRenderer.setScissor(left, bottom, w, h);
                      modalRenderer.render(item.scene, item.camera);
                }
                modalRenderer.setScissorTest(false);
            } else {
                modalRenderer.clear(); // Clear modal canvas if no scene
            }
            
            requestAnimationFrame(render);
        }

        window.addEventListener('mouseup', () => {
            scenes.forEach(s => s.isDragging = false);
            if(modalSceneData) modalSceneData.isDragging = false;
        });

        window.addEventListener('mousemove', (e) => {
            const handleDrag = (s) => {
                if (s.isDragging) {
                    const dx = e.clientX - s.lastMouse.x;
                    const dy = e.clientY - s.lastMouse.y;
                    s.mesh.rotation.y += dx * 0.01;
                    s.mesh.rotation.x += dy * 0.01;
                    s.lastMouse.x = e.clientX;
                    s.lastMouse.y = e.clientY;
                }
            };
            scenes.forEach(handleDrag);
            if(modalSceneData) handleDrag(modalSceneData);
        });

        // =========================================================================
        // ======================== APP LOGIC & UI =================================
        // =========================================================================

        let currentEditCatId = null;
        let currentEditItemId = null;
        let originalItemState = null; // Backup for Cancel

        function rebuildApp() {
            // Clean up scenes for memory optimization
            scenes = [];
            
            document.getElementById('content-anchor').innerHTML = '';
            renderHTML();
            
            // Main Catalog Scenes
            CATEGORIES.forEach((cat) => {
                cat.items.forEach((item) => {
                    const el = document.getElementById(`scene-${item.id}`);
                    if (el) scenes.push(createSceneForItem(el, item, false));
                });
            });

            // Modal Scene (if open)
            modalSceneData = null; // Reset
            if(document.getElementById('editor-modal').classList.contains('active') && currentEditCatId) {
                const cat = CATEGORIES.find(c => c.id === currentEditCatId);
                const item = cat.items.find(i => i.id === currentEditItemId);
                if(item) {
                    const modalEl = document.getElementById('modal-scene-target');
                    modalSceneData = createSceneForItem(modalEl, item, true);
                }
            }
        }

        function renderHTML() {
            const container = document.getElementById('content-anchor');
            let html = `<div class="page-sheet">`;

            html += `
                <div class="flex justify-between items-end border-b-2 border-gray-800 pb-4 mb-8">
                    <div>
                        <img src="${COMPANY_INFO.logoUrl}" alt="Logo" class="h-16 mb-2 object-contain">
                    </div>
                    <div class="text-right">
                        <h2 class="text-xl font-bold text-gray-800">${COMPANY_INFO.subtitle}</h2>
                        <p class="text-sm text-gray-500 mt-1">${COMPANY_INFO.contact}</p>
                    </div>
                </div>
            `;

            CATEGORIES.forEach((cat) => {
                html += `
                    <div class="mb-8 page-break-avoid">
                        <h3 class="text-lg font-bold uppercase text-gray-800 border-l-4 border-gray-800 pl-3 mb-2">${cat.title}</h3>
                        ${cat.description ? `<p class="text-sm text-gray-600 mb-4 max-w-2xl">${cat.description}</p>` : ''}
                        
                        <div class="grid grid-cols-4 gap-6 mb-4">
                            ${cat.items.map(item => `
                                <div class="flex flex-col group page-break-avoid relative">
                                    <div class="relative w-full aspect-square mb-3 bg-transparent rounded transition">
                                        <div id="scene-${item.id}" class="scene-element"></div>
                                        <img id="print-${item.id}" class="print-image" src="" />
                                        
                                        <div class="item-controls absolute inset-0 z-50 flex flex-col justify-between p-2">
                                            <div class="flex justify-end gap-2">
                                                <button onclick="duplicateItem(${cat.id}, ${item.id})" class="control-btn" title="Duplicate Item">
                                                    <i class="fas fa-copy text-xs"></i>
                                                </button>
                                                <button onclick="deleteItemDirectly(${cat.id}, ${item.id})" class="control-btn btn-delete text-red-500" title="Delete Item">
                                                    <i class="fas fa-trash text-xs"></i>
                                                </button>
                                                <button onclick="openModal(${cat.id}, ${item.id})" class="control-btn" title="Edit Item">
                                                    <i class="fas fa-pen text-xs"></i>
                                                </button>
                                            </div>
                                            
                                            <div class="flex justify-between items-center mt-auto">
                                                <button onclick="moveItem(${cat.id}, ${item.id}, -1)" class="control-btn w-8 h-8 opacity-70 hover:opacity-100" title="Move Left">
                                                    <i class="fas fa-chevron-left text-xs"></i>
                                                </button>
                                                <button onclick="moveItem(${cat.id}, ${item.id}, 1)" class="control-btn w-8 h-8 opacity-70 hover:opacity-100" title="Move Right">
                                                    <i class="fas fa-chevron-right text-xs"></i>
                                                </button>
                                            </div>
                                        </div>

                                    </div>
                                    <div class="text-center">
                                        <p class="text-xs font-bold text-gray-800 uppercase leading-tight tracking-wide">${item.name}</p>
                                    </div>
                                </div>
                            `).join('')}
                            
                            <div class="add-card flex flex-col justify-center items-center aspect-square border-2 border-dashed border-gray-300 rounded hover:border-blue-500 hover:bg-blue-50 cursor-pointer transition group" onclick="addItem(${cat.id})">
                                <div class="w-12 h-12 rounded-full bg-gray-100 flex items-center justify-center mb-2 group-hover:bg-blue-200 group-hover:text-blue-700 transition">
                                    <i class="fas fa-plus text-gray-400 group-hover:text-blue-600"></i>
                                </div>
                                <span class="text-xs font-bold text-gray-400 group-hover:text-blue-600 uppercase">Add Item</span>
                            </div>
                        </div>
                    </div>
                `;
            });

            html += `
                <div class="absolute bottom-8 left-0 right-0 text-center">
                    <div class="w-16 h-1 bg-gray-500 mx-auto mb-2"></div>
                    <p class="text-xs text-gray-400 uppercase tracking-widest">${COMPANY_INFO.title} &copy; ${currentYear}</p>
                </div>
            </div>`;

            container.innerHTML = html;
        }

        // =========================================================================
        // ======================== POPUP / MODAL LOGIC ============================
        // =========================================================================

        function openModal(catId, itemId) {
            currentEditCatId = catId;
            currentEditItemId = itemId;
            
            const cat = CATEGORIES.find(c => c.id === catId);
            const item = cat.items.find(i => i.id === itemId);

            // Create Backup for Cancel
            originalItemState = JSON.parse(JSON.stringify(item));

            const controlsContainer = document.getElementById('modal-controls');
            
            let currentStyleKey = 'none';
            for (const [key, style] of Object.entries(TEXTURE_STYLES)) {
                if (style.mapId === (item.mapId||'none') && style.bumpId === (item.bumpId||'none')) {
                    currentStyleKey = key;
                    break;
                }
            }
            const isTextureMode = item.renderMode === 'texture';

            controlsContainer.innerHTML = `
                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <label class="block text-xs font-bold text-gray-500 mb-1">Item Name</label>
                        <input type="text" value="${item.name}" 
                            onchange="updateCurrentItem('name', this.value)"
                            class="w-full border rounded p-2 font-bold text-gray-800 focus:ring-2 ring-blue-500 outline-none">
                    </div>
                    <div>
                        <label class="block text-xs font-bold text-gray-500 mb-1">Shape</label>
                        <select onchange="updateCurrentItem('shape', this.value)" class="w-full border rounded p-2 bg-white cursor-pointer">
                            ${SHAPE_TYPES.map(t => `<option value="${t}" ${item.shape === t ? 'selected' : ''}>${t.toUpperCase()}</option>`).join('')}
                        </select>
                    </div>
                </div>

                <div class="bg-blue-50 p-4 rounded-lg border border-blue-100">
                    <label class="block text-xs font-bold text-blue-600 uppercase mb-2">Apply Quick Preset</label>
                    <select onchange="applyPresetToCurrent(this.value)" class="w-full border rounded p-2 bg-white text-sm">
                        <option value="">Select a preset...</option>
                        ${Object.keys(MATERIAL_PRESETS).map(k => `<option value="${k}">${MATERIAL_PRESETS[k].label}</option>`).join('')}
                    </select>
                    

                </div>

                <hr class="border-gray-200">

                <div class="flex items-center justify-between">
                     <label class="text-sm font-bold text-gray-700">Display Mode</label>
                     <div class="bg-gray-200 p-1 rounded-lg flex text-sm font-bold">
                        <button onclick="updateCurrentItem('renderMode', 'texture')" class="px-4 py-1 rounded ${isTextureMode ? 'bg-white shadow text-blue-600' : 'text-gray-500'} transition">Texture</button>
                        <button onclick="updateCurrentItem('renderMode', 'color')" class="px-4 py-1 rounded ${!isTextureMode ? 'bg-white shadow text-blue-600' : 'text-gray-500'} transition">Color</button>
                     </div>
                </div>

                <div>
                    <label class="block text-xs font-bold text-gray-500 mb-1">Base Texture / Bump Pattern</label>
                    <select onchange="updateCurrentStyle(this.value)" class="w-full border rounded p-2 bg-white text-sm">
                         ${Object.keys(TEXTURE_STYLES).map(k => `<option value="${k}" ${currentStyleKey === k ? 'selected' : ''}>${TEXTURE_STYLES[k].label}</option>`).join('')}
                    </select>
                    <p class="text-[10px] text-gray-400 mt-1">Note: This defines the Bump Map pattern even in Color Mode.</p>
                </div>

                <div class="${isTextureMode ? 'opacity-50' : ''} transition">
                    <label class="block text-xs font-bold text-gray-500 mb-1">Base Color</label>
                    <div class="flex gap-2 items-center">
                        <input type="color" value="${item.color}" 
                            onchange="updateCurrentItem('color', this.value)"
                            class="w-10 h-10 rounded border-0 cursor-pointer">
                        <span class="text-xs text-gray-400 font-mono">${item.color}</span>
                    </div>
                </div>

                <div class="space-y-4 pt-2">
                    <div class="flex items-center gap-4">
                        <label class="w-20 text-xs font-bold text-gray-600">Scale</label>
                        <input type="range" min="0.1" max="2.0" step="0.1" value="${item.textureScale}" oninput="updateCurrentItem('textureScale', this.value)">
                    </div>

                    <div class="flex items-center gap-4">
                        <label class="w-20 text-xs font-bold text-gray-600">Brightness</label>
                        <input type="range" min="0.0" max="2.0" step="0.1" value="${item.brightness !== undefined ? item.brightness : 1.0}" oninput="updateCurrentItem('brightness', this.value)">
                    </div>
                    <div class="flex items-center gap-4">
                        <label class="w-20 text-xs font-bold text-gray-600">Contrast</label>
                        <input type="range" min="0.5" max="2.0" step="0.1" value="${item.contrast !== undefined ? item.contrast : 1.0}" oninput="updateCurrentItem('contrast', this.value)">
                    </div>

                    <hr class="border-gray-100">

                    <div class="flex items-center gap-4">
                        <label class="w-20 text-xs font-bold text-gray-600">Gloss/Rough</label>
                        <input type="range" min="0" max="1" step="0.05" value="${item.roughness}" oninput="updateCurrentItem('roughness', this.value)">
                    </div>
                    <div class="flex items-center gap-4">
                        <label class="w-20 text-xs font-bold text-gray-600">Plastic/Metal</label>
                        <input type="range" min="0" max="1" step="0.05" value="${item.metalness}" oninput="updateCurrentItem('metalness', this.value)">
                    </div>
                    <div class="flex items-center gap-4">
                        <label class="w-20 text-xs font-bold text-gray-600">Bump Depth</label>
                        <input type="range" min="0" max="0.1" step="0.001" value="${item.bumpScale}" oninput="updateCurrentItem('bumpScale', this.value)">
                    </div>
                </div>
            `;

            document.getElementById('editor-modal').classList.add('active');
            rebuildApp();
        }

        // NEW FUNCTION TO COPY SETTINGS
        function copyAsPreset() {
            const cat = CATEGORIES.find(c => c.id === currentEditCatId);
            const item = cat.items.find(i => i.id === currentEditItemId);

            // Find current style key
            let styleKey = 'none';
            for (const [key, s] of Object.entries(TEXTURE_STYLES)) {
                if (s.mapId === (item.mapId || 'none') && s.bumpId === (item.bumpId || 'none')) {
                    styleKey = key;
                    break;
                }
            }

            // Create safe key from name
            const keyName = item.name.toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, '');
            
            // Format string
            const presetString = `'${keyName}': { label: '${item.name}', roughness: ${item.roughness}, metalness: ${item.metalness}, bumpScale: ${item.bumpScale}, style: '${styleKey}' },`;

            navigator.clipboard.writeText(presetString).then(() => {
                const btn = document.getElementById('btn-copy-preset');
                const originalText = btn.innerHTML;
                btn.innerHTML = '<i class="fas fa-check"></i> Copied!';
                btn.classList.add('text-green-600');
                btn.classList.remove('text-blue-600');
                setTimeout(() => {
                    btn.innerHTML = originalText;
                    btn.classList.remove('text-green-600');
                    btn.classList.add('text-blue-600');
                }, 2000);
            });
        }

        function cancelEdit() {
            if (originalItemState && currentEditCatId && currentEditItemId) {
                // Restore state
                const cat = CATEGORIES.find(c => c.id === currentEditCatId);
                const item = cat.items.find(i => i.id === currentEditItemId);
                if (cat && item) {
                    Object.assign(item, originalItemState);
                }
            }
            closeModal();
        }

        function closeModal() {
            document.getElementById('editor-modal').classList.remove('active');
            currentEditCatId = null;
            currentEditItemId = null;
            originalItemState = null;
            rebuildApp(); 
        }

        function updateCurrentItem(field, value) {
            const cat = CATEGORIES.find(c => c.id === currentEditCatId);
            const item = cat.items.find(i => i.id === currentEditItemId);
            
            if (['roughness', 'metalness', 'bumpScale', 'textureScale', 'brightness', 'contrast'].includes(field)) {
                item[field] = parseFloat(value);
            } else {
                item[field] = value;
            }

            if(field === 'renderMode') {
                openModal(currentEditCatId, currentEditItemId); 
            } else {
                rebuildApp();
            }
        }

        function updateCurrentStyle(styleKey) {
            const cat = CATEGORIES.find(c => c.id === currentEditCatId);
            const item = cat.items.find(i => i.id === currentEditItemId);
            const style = TEXTURE_STYLES[styleKey];
            if(style) {
                item.mapId = style.mapId;
                item.bumpId = style.bumpId;
            }
            rebuildApp();
        }

        function applyPresetToCurrent(presetKey) {
            if(!presetKey) return;
            const cat = CATEGORIES.find(c => c.id === currentEditCatId);
            const item = cat.items.find(i => i.id === currentEditItemId);
            const preset = MATERIAL_PRESETS[presetKey];
            
            if(preset) {
                item.roughness = preset.roughness;
                item.metalness = preset.metalness;
                item.bumpScale = preset.bumpScale;
                const style = TEXTURE_STYLES[preset.style];
                if(style) {
                    item.mapId = style.mapId;
                    item.bumpId = style.bumpId;
                }
            }
            rebuildApp();
            openModal(currentEditCatId, currentEditItemId); 
        }

        function deleteCurrentItem() {
            if(!confirm("Delete this material?")) return;
            const cat = CATEGORIES.find(c => c.id === currentEditCatId);
            cat.items = cat.items.filter(i => i.id !== currentEditItemId);
            closeModal();
        }

        function deleteItemDirectly(catId, itemId) {
            if(!confirm("Delete this material?")) return;
            const cat = CATEGORIES.find(c => c.id === catId);
            cat.items = cat.items.filter(i => i.id !== itemId);
            rebuildApp();
        }

        function moveItem(catId, itemId, direction) {
            const cat = CATEGORIES.find(c => c.id === catId);
            const index = cat.items.findIndex(i => i.id === itemId);
            
            if (direction === -1 && index > 0) {
                [cat.items[index], cat.items[index - 1]] = [cat.items[index - 1], cat.items[index]];
            } else if (direction === 1 && index < cat.items.length - 1) {
                [cat.items[index], cat.items[index + 1]] = [cat.items[index + 1], cat.items[index]];
            }
            rebuildApp(); 
        }

        function duplicateItem(catId, itemId) {
            const cat = CATEGORIES.find(c => c.id === catId);
            const index = cat.items.findIndex(i => i.id === itemId);
            if(index === -1) return;

            const itemToClone = cat.items[index];
            const newItem = JSON.parse(JSON.stringify(itemToClone));
            newItem.id = Date.now();
            newItem.name = newItem.name + " (Copy)";

            // Insert after original
            cat.items.splice(index + 1, 0, newItem);
            rebuildApp();
        }

        function addItem(catId) {
            const cat = CATEGORIES.find(c => c.id === catId);
            const newId = Date.now(); 
            const newItem = {
                id: newId,
                name: "New Material",
                color: "#cccccc",
                shape: "cube",
                renderMode: 'color', 
                mapId: "none",
                bumpId: "none",
                roughness: 0.5,
                metalness: 0,
                bumpScale: 0.005,
                textureScale: 1.0,
                brightness: 1.0,
                contrast: 1.0
            };
            cat.items.push(newItem);
            rebuildApp();
            openModal(catId, newId);
        }

        function downloadHTML() {
            let htmlContent = document.documentElement.outerHTML;
            const dataStartMarker = '// -- DATA_START --';
            const dataEndMarker = '// -- DATA_END --';
            const newScriptData = `let CATEGORIES = ${JSON.stringify(CATEGORIES, null, 4)};`;
            const regex = new RegExp(`${dataStartMarker}[\\s\\S]*?${dataEndMarker}`);
            
            if (regex.test(htmlContent)) {
                htmlContent = htmlContent.replace(regex, `${dataStartMarker}\n        ${newScriptData}\n        ${dataEndMarker}`);
            } else {
                alert("Error saving data structure. Please copy manually.");
                return;
            }

            const blob = new Blob([htmlContent], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'wishbone-catalog-saved.html';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        async function prepareAndPrint() {
            isAnimating = false;
            if(document.getElementById('editor-modal').classList.contains('active')) {
                closeModal();
            }
            
            const size = 1024;
            renderer.setSize(size, size);
            renderer.setScissorTest(false);

            for (const item of scenes) {
                if(item.element.id === 'modal-scene-target') continue; 

                const shapeDef = SHAPE_DEFAULTS[item.shape];
                if(shapeDef) {
                    item.mesh.rotation.set(shapeDef.rotation.x, shapeDef.rotation.y, shapeDef.rotation.z);
                } else {
                    item.mesh.rotation.set(0,0,0);
                }
                
                renderer.clear();
                renderer.render(item.scene, item.camera);
                const dataURL = renderer.domElement.toDataURL('image/png');
                const img = document.getElementById(`print-${item.element.id.split('-')[1]}`);
                if (img) img.src = dataURL;
            }

            setTimeout(() => {
                window.print();
                isAnimating = true;
                requestAnimationFrame(render);
            }, 500);
        }

        window.onload = function() {
            initThree();
            rebuildApp();
            render();
        };

    </script>
</body>
</html>